<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MASFENON: WeightedEdgeGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MASFENON
   </div>
   <div id="projectbrief">Multi-Agent Adaptive Simulation Framework for Evolution in Networks of Networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classWeightedEdgeGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">WeightedEdgeGraph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="WeightedEdgeGraph_8hxx_source.html">WeightedEdgeGraph.hxx</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for WeightedEdgeGraph:</div>
<div class="dyncontent">
<div class="center"><img src="classWeightedEdgeGraph__coll__graph.png" border="0" usemap="#aWeightedEdgeGraph_coll__map" alt="Collaboration graph"/></div>
<map name="aWeightedEdgeGraph_coll__map" id="aWeightedEdgeGraph_coll__map">
<area shape="rect" title=" " alt="" coords="5,93,160,119"/>
<area shape="rect" href="classMatrix.html" title=" " alt="" coords="13,5,152,31"/>
<area shape="poly" title=" " alt="" coords="85,45,85,93,80,93,80,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1523d1fe59886ee43c26e15fcd58d55" id="r_ab1523d1fe59886ee43c26e15fcd58d55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ab1523d1fe59886ee43c26e15fcd58d55">WeightedEdgeGraph</a> ()</td></tr>
<tr class="memdesc:ab1523d1fe59886ee43c26e15fcd58d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for creating an empty weighted edge graph.  <br /></td></tr>
<tr class="separator:ab1523d1fe59886ee43c26e15fcd58d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8ec9dc0aebd35818be4555c111bdd" id="r_a46e8ec9dc0aebd35818be4555c111bdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a46e8ec9dc0aebd35818be4555c111bdd">WeightedEdgeGraph</a> (int numNodes)</td></tr>
<tr class="memdesc:a46e8ec9dc0aebd35818be4555c111bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a weighted edge graph with a specified number of nodes.  <br /></td></tr>
<tr class="separator:a46e8ec9dc0aebd35818be4555c111bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda55d58f9e50f27158bbf243a46d8f2" id="r_adda55d58f9e50f27158bbf243a46d8f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#adda55d58f9e50f27158bbf243a46d8f2">WeightedEdgeGraph</a> (std::vector&lt; std::string &gt; &amp;nodeNames)</td></tr>
<tr class="memdesc:adda55d58f9e50f27158bbf243a46d8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a weighted edge graph with specified node names.  <br /></td></tr>
<tr class="separator:adda55d58f9e50f27158bbf243a46d8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1267e5cc0534ecc6565f600595270c" id="r_a6e1267e5cc0534ecc6565f600595270c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a6e1267e5cc0534ecc6565f600595270c">WeightedEdgeGraph</a> (std::vector&lt; std::string &gt; &amp;nodeNames, std::vector&lt; double &gt; &amp;nodeVal)</td></tr>
<tr class="memdesc:a6e1267e5cc0534ecc6565f600595270c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a weighted edge graph with specified node names and values.  <br /></td></tr>
<tr class="separator:a6e1267e5cc0534ecc6565f600595270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab574c12b8823863bb8570c0ad3e62579" id="r_ab574c12b8823863bb8570c0ad3e62579"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ab574c12b8823863bb8570c0ad3e62579">WeightedEdgeGraph</a> (const <a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt; &amp;_adjMatrix)</td></tr>
<tr class="memdesc:ab574c12b8823863bb8570c0ad3e62579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating a weighted edge graph from an adjacency matrix.  <br /></td></tr>
<tr class="separator:ab574c12b8823863bb8570c0ad3e62579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bb43eb23adc27906e698767a3d4f92" id="r_a43bb43eb23adc27906e698767a3d4f92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a43bb43eb23adc27906e698767a3d4f92">~WeightedEdgeGraph</a> ()</td></tr>
<tr class="memdesc:a43bb43eb23adc27906e698767a3d4f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for cleaning up the allocated memory.  <br /></td></tr>
<tr class="separator:a43bb43eb23adc27906e698767a3d4f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa03f9df08719471ee4698bc88cb34ea" id="r_aaa03f9df08719471ee4698bc88cb34ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#aaa03f9df08719471ee4698bc88cb34ea">addEdge</a> (int node1, int node2, double weight, bool directed=true)</td></tr>
<tr class="memdesc:aaa03f9df08719471ee4698bc88cb34ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add an edge to the graph.  <br /></td></tr>
<tr class="separator:aaa03f9df08719471ee4698bc88cb34ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbb2587b4771c016bdd36f6be62cee2" id="r_a8bbb2587b4771c016bdd36f6be62cee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a8bbb2587b4771c016bdd36f6be62cee2">addEdge</a> (std::string node1name, std::string node2name, double weight, bool directed=true)</td></tr>
<tr class="memdesc:a8bbb2587b4771c016bdd36f6be62cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add an edge to the graph using node names.  <br /></td></tr>
<tr class="separator:a8bbb2587b4771c016bdd36f6be62cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d7a47ac0dd1ec17466250a6713a89d" id="r_a45d7a47ac0dd1ec17466250a6713a89d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a45d7a47ac0dd1ec17466250a6713a89d">getEdgeWeight</a> (int node1, int node2) const</td></tr>
<tr class="memdesc:a45d7a47ac0dd1ec17466250a6713a89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the weight of an edge between two nodes.  <br /></td></tr>
<tr class="separator:a45d7a47ac0dd1ec17466250a6713a89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750eb82403adfe2ddae8b6ad75b50bec" id="r_a750eb82403adfe2ddae8b6ad75b50bec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a750eb82403adfe2ddae8b6ad75b50bec">getEdgeWeight</a> (std::string node1, std::string node2) const</td></tr>
<tr class="memdesc:a750eb82403adfe2ddae8b6ad75b50bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the weight of an edge between two nodes using their names.  <br /></td></tr>
<tr class="separator:a750eb82403adfe2ddae8b6ad75b50bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441ff5c47a1cd44684b7ebc6fb3f2494" id="r_a441ff5c47a1cd44684b7ebc6fb3f2494"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a441ff5c47a1cd44684b7ebc6fb3f2494">getIndexFromName</a> (std::string name) const</td></tr>
<tr class="memdesc:a441ff5c47a1cd44684b7ebc6fb3f2494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the index of a node by its name.  <br /></td></tr>
<tr class="separator:a441ff5c47a1cd44684b7ebc6fb3f2494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec9cac4c7991f04ffe7044d01348754" id="r_a3ec9cac4c7991f04ffe7044d01348754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a3ec9cac4c7991f04ffe7044d01348754">addNode</a> (double value=0)</td></tr>
<tr class="memdesc:a3ec9cac4c7991f04ffe7044d01348754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a node to the graph.  <br /></td></tr>
<tr class="separator:a3ec9cac4c7991f04ffe7044d01348754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165ea3dae2483f4e59d31c87ded4927b" id="r_a165ea3dae2483f4e59d31c87ded4927b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a165ea3dae2483f4e59d31c87ded4927b">addNode</a> (std::string name, double value=0)</td></tr>
<tr class="memdesc:a165ea3dae2483f4e59d31c87ded4927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a node to the graph with a specified name.  <br /></td></tr>
<tr class="separator:a165ea3dae2483f4e59d31c87ded4927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad902cfe44e2526ed5587cbee3d9a5333" id="r_ad902cfe44e2526ed5587cbee3d9a5333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ad902cfe44e2526ed5587cbee3d9a5333">addNodes</a> (const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:ad902cfe44e2526ed5587cbee3d9a5333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add multiple nodes to the graph.  <br /></td></tr>
<tr class="separator:ad902cfe44e2526ed5587cbee3d9a5333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b845b5980b8c3c1d54889915e6bb4" id="r_a241b845b5980b8c3c1d54889915e6bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a241b845b5980b8c3c1d54889915e6bb4">addNodes</a> (const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; double &gt; &amp;values=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:a241b845b5980b8c3c1d54889915e6bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add multiple nodes to the graph with specified names and values.  <br /></td></tr>
<tr class="separator:a241b845b5980b8c3c1d54889915e6bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb151a19f4b2713dfaa37adeed3afd4e" id="r_abb151a19f4b2713dfaa37adeed3afd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#abb151a19f4b2713dfaa37adeed3afd4e">addNodesAndCopyNew</a> (const std::vector&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:abb151a19f4b2713dfaa37adeed3afd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add multiple nodes to the graph and copy the graph into a new graph in dynamic memory.  <br /></td></tr>
<tr class="separator:abb151a19f4b2713dfaa37adeed3afd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842b8a68ecd898fd51fba251f0637182" id="r_a842b8a68ecd898fd51fba251f0637182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a842b8a68ecd898fd51fba251f0637182">addNodesAndCopyNew</a> (const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; double &gt; &amp;values=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:a842b8a68ecd898fd51fba251f0637182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add multiple nodes to the graph and copy the graph into a new graph in dynamic memory.  <br /></td></tr>
<tr class="separator:a842b8a68ecd898fd51fba251f0637182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa05d3d6e955d4559dd3cb5e75e7dcb" id="r_a1fa05d3d6e955d4559dd3cb5e75e7dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a1fa05d3d6e955d4559dd3cb5e75e7dcb">setNodeValue</a> (int node, double value)</td></tr>
<tr class="memdesc:a1fa05d3d6e955d4559dd3cb5e75e7dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the value of a node by its index.  <br /></td></tr>
<tr class="separator:a1fa05d3d6e955d4559dd3cb5e75e7dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723f9a865013c8e72b19b2395bca6b8" id="r_ab723f9a865013c8e72b19b2395bca6b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ab723f9a865013c8e72b19b2395bca6b8">setNodeValue</a> (std::string node, double value)</td></tr>
<tr class="memdesc:ab723f9a865013c8e72b19b2395bca6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the value of a node by its name.  <br /></td></tr>
<tr class="separator:ab723f9a865013c8e72b19b2395bca6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac176fd34f2b9d4e38cf35d416dcfcaae" id="r_ac176fd34f2b9d4e38cf35d416dcfcaae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ac176fd34f2b9d4e38cf35d416dcfcaae">setNodeName</a> (std::string nodenameTarget, std::string nodenameSet)</td></tr>
<tr class="memdesc:ac176fd34f2b9d4e38cf35d416dcfcaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the names of the nodes in the graph.  <br /></td></tr>
<tr class="separator:ac176fd34f2b9d4e38cf35d416dcfcaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c86e57f044655608a3e27551147269b" id="r_a2c86e57f044655608a3e27551147269b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a2c86e57f044655608a3e27551147269b">setNodesNames</a> (const std::vector&lt; std::string &gt; &amp;nodenameSets, const std::vector&lt; std::string &gt; &amp;nodenameTargets=std::vector&lt; std::string &gt;())</td></tr>
<tr class="memdesc:a2c86e57f044655608a3e27551147269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the names of multiple nodes in the graph.  <br /></td></tr>
<tr class="separator:a2c86e57f044655608a3e27551147269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9aadcfc05bf0fe0ab75e1318146f42" id="r_a0c9aadcfc05bf0fe0ab75e1318146f42"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a0c9aadcfc05bf0fe0ab75e1318146f42">getNodeName</a> (int node) const</td></tr>
<tr class="memdesc:a0c9aadcfc05bf0fe0ab75e1318146f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the node name by its index.  <br /></td></tr>
<tr class="separator:a0c9aadcfc05bf0fe0ab75e1318146f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fb3424f09147387c69ff7f39ffc23e" id="r_aa8fb3424f09147387c69ff7f39ffc23e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#aa8fb3424f09147387c69ff7f39ffc23e">getNodeValue</a> (int node) const</td></tr>
<tr class="memdesc:aa8fb3424f09147387c69ff7f39ffc23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the value of a node by its index.  <br /></td></tr>
<tr class="separator:aa8fb3424f09147387c69ff7f39ffc23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779d6c8587d6fc1d452110271fda8139" id="r_a779d6c8587d6fc1d452110271fda8139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a779d6c8587d6fc1d452110271fda8139">getNodeValue</a> (std::string node) const</td></tr>
<tr class="memdesc:a779d6c8587d6fc1d452110271fda8139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the value of a node by its name.  <br /></td></tr>
<tr class="separator:a779d6c8587d6fc1d452110271fda8139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11802cc18552ac393876d86eab64a0be" id="r_a11802cc18552ac393876d86eab64a0be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a11802cc18552ac393876d86eab64a0be">getNodeValues</a> (const std::vector&lt; int &gt; &amp;node) const</td></tr>
<tr class="memdesc:a11802cc18552ac393876d86eab64a0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the values of multiple nodes by their indexes.  <br /></td></tr>
<tr class="separator:a11802cc18552ac393876d86eab64a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73efc6e50ff603098d8904ac0a36b84c" id="r_a73efc6e50ff603098d8904ac0a36b84c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a73efc6e50ff603098d8904ac0a36b84c">getNodeValues</a> (const std::vector&lt; std::string &gt; &amp;node=std::vector&lt; std::string &gt;()) const</td></tr>
<tr class="memdesc:a73efc6e50ff603098d8904ac0a36b84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the values of multiple nodes by their names.  <br /></td></tr>
<tr class="separator:a73efc6e50ff603098d8904ac0a36b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3877b03277780ad7634365a771193c5" id="r_ae3877b03277780ad7634365a771193c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ae3877b03277780ad7634365a771193c5">makeMatrix</a> ()</td></tr>
<tr class="memdesc:ae3877b03277780ad7634365a771193c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a new adjacency matrix from the current graph.  <br /></td></tr>
<tr class="separator:ae3877b03277780ad7634365a771193c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3513ceac058873d1d9f4eb590c89c896" id="r_a3513ceac058873d1d9f4eb590c89c896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a3513ceac058873d1d9f4eb590c89c896">getNumNodes</a> () const</td></tr>
<tr class="memdesc:a3513ceac058873d1d9f4eb590c89c896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the number of nodes in the graph(immutable).  <br /></td></tr>
<tr class="separator:a3513ceac058873d1d9f4eb590c89c896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbd44f62fae942ab2fd71ac3f9f31b5" id="r_a1dbd44f62fae942ab2fd71ac3f9f31b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a1dbd44f62fae942ab2fd71ac3f9f31b5">getNumEdges</a> () const</td></tr>
<tr class="memdesc:a1dbd44f62fae942ab2fd71ac3f9f31b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the number of edges in the graph(immutable).  <br /></td></tr>
<tr class="separator:a1dbd44f62fae942ab2fd71ac3f9f31b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed769ff58f478aaccf711bd0252d61d3" id="r_aed769ff58f478aaccf711bd0252d61d3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#aed769ff58f478aaccf711bd0252d61d3">getNodeNames</a> () const</td></tr>
<tr class="memdesc:aed769ff58f478aaccf711bd0252d61d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the names of the nodes in the graph(immutable).  <br /></td></tr>
<tr class="separator:aed769ff58f478aaccf711bd0252d61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf9979070b8837a84ef80a4e99265b2" id="r_a1cf9979070b8837a84ef80a4e99265b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a1cf9979070b8837a84ef80a4e99265b2">outDegreeOfNode</a> (int node) const</td></tr>
<tr class="memdesc:a1cf9979070b8837a84ef80a4e99265b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the out degree of a certain node in the graph(immutable).  <br /></td></tr>
<tr class="separator:a1cf9979070b8837a84ef80a4e99265b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2766c352071d25a6da4b8a2cce0f8db0" id="r_a2766c352071d25a6da4b8a2cce0f8db0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a2766c352071d25a6da4b8a2cce0f8db0">inDegreeOfNode</a> (int node) const</td></tr>
<tr class="memdesc:a2766c352071d25a6da4b8a2cce0f8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the in degree of a certain node in the graph(immutable).  <br /></td></tr>
<tr class="separator:a2766c352071d25a6da4b8a2cce0f8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80f2ecd2beaecc5655af4158b1a2f27" id="r_ad80f2ecd2beaecc5655af4158b1a2f27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ad80f2ecd2beaecc5655af4158b1a2f27">degreeOfNode</a> (int node) const</td></tr>
<tr class="memdesc:ad80f2ecd2beaecc5655af4158b1a2f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the degree of a certain node in the graph(immutable).  <br /></td></tr>
<tr class="separator:ad80f2ecd2beaecc5655af4158b1a2f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3bf2e7b630fc443a430ab6a5ecf1f1" id="r_a9d3bf2e7b630fc443a430ab6a5ecf1f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a9d3bf2e7b630fc443a430ab6a5ecf1f1">containsNode</a> (std::string node) const</td></tr>
<tr class="memdesc:a9d3bf2e7b630fc443a430ab6a5ecf1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to know if a node is in the graph(immutable)  <br /></td></tr>
<tr class="separator:a9d3bf2e7b630fc443a430ab6a5ecf1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0455f9437b86554fb36209b736211e" id="r_a9f0455f9437b86554fb36209b736211e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a9f0455f9437b86554fb36209b736211e">getPredecessors</a> (int node) const</td></tr>
<tr class="memdesc:a9f0455f9437b86554fb36209b736211e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the predecessors of a node by its index(immutable).  <br /></td></tr>
<tr class="separator:a9f0455f9437b86554fb36209b736211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fc593e03daa34d9c0fcc1a24865f5a" id="r_ab7fc593e03daa34d9c0fcc1a24865f5a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ab7fc593e03daa34d9c0fcc1a24865f5a">getSuccessors</a> (int node) const</td></tr>
<tr class="memdesc:ab7fc593e03daa34d9c0fcc1a24865f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the successors of a node by its index(immutable).  <br /></td></tr>
<tr class="separator:ab7fc593e03daa34d9c0fcc1a24865f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e716dbe1a72138daca3478f39f0bb5" id="r_a14e716dbe1a72138daca3478f39f0bb5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a14e716dbe1a72138daca3478f39f0bb5">getNeighbors</a> (int node) const</td></tr>
<tr class="memdesc:a14e716dbe1a72138daca3478f39f0bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the neighbors of a node by its index(immutable).  <br /></td></tr>
<tr class="separator:a14e716dbe1a72138daca3478f39f0bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46261714b6fe50b311cd727dbb6ce043" id="r_a46261714b6fe50b311cd727dbb6ce043"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a46261714b6fe50b311cd727dbb6ce043">getPredecessors</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:a46261714b6fe50b311cd727dbb6ce043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the predecessors of a node by its name(immutable).  <br /></td></tr>
<tr class="separator:a46261714b6fe50b311cd727dbb6ce043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1127dc0c0e930555827172d1015710" id="r_a2c1127dc0c0e930555827172d1015710"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a2c1127dc0c0e930555827172d1015710">getSuccessors</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:a2c1127dc0c0e930555827172d1015710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the successors of a node by its name(immutable).  <br /></td></tr>
<tr class="separator:a2c1127dc0c0e930555827172d1015710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc42c47f150546dcc0ab07a25216deca" id="r_acc42c47f150546dcc0ab07a25216deca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#acc42c47f150546dcc0ab07a25216deca">getNeighbors</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:acc42c47f150546dcc0ab07a25216deca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the neighbors of a node by its name(immutable).  <br /></td></tr>
<tr class="separator:acc42c47f150546dcc0ab07a25216deca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c94e60e58a2e8aefac52fe8db3391d" id="r_a12c94e60e58a2e8aefac52fe8db3391d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a12c94e60e58a2e8aefac52fe8db3391d">getnodeValuesStr</a> () const</td></tr>
<tr class="memdesc:a12c94e60e58a2e8aefac52fe8db3391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the string representation of the node values(immutable)  <br /></td></tr>
<tr class="separator:a12c94e60e58a2e8aefac52fe8db3391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c1ac5331d89636ef6ee0be9629023" id="r_ab81c1ac5331d89636ef6ee0be9629023"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ab81c1ac5331d89636ef6ee0be9629023">getAdjList</a> (int node) const</td></tr>
<tr class="memdesc:ab81c1ac5331d89636ef6ee0be9629023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the adjacency list of a node by its index(immutable).  <br /></td></tr>
<tr class="separator:ab81c1ac5331d89636ef6ee0be9629023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad408a4eb90ced6e0253c2f783c8f1221" id="r_ad408a4eb90ced6e0253c2f783c8f1221"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ad408a4eb90ced6e0253c2f783c8f1221">getAdjList</a> (std::string node) const</td></tr>
<tr class="memdesc:ad408a4eb90ced6e0253c2f783c8f1221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the adjacency list of a node by its name(immutable).  <br /></td></tr>
<tr class="separator:ad408a4eb90ced6e0253c2f783c8f1221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374d247510ef156ff79075a0fadf76e0" id="r_a374d247510ef156ff79075a0fadf76e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a374d247510ef156ff79075a0fadf76e0">getAdjListStr</a> (int node) const</td></tr>
<tr class="memdesc:a374d247510ef156ff79075a0fadf76e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the string representation of the adjacency list of a node by its index(immutable).  <br /></td></tr>
<tr class="separator:a374d247510ef156ff79075a0fadf76e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac55e026fc51e480bb83f6a1425dffa8" id="r_aac55e026fc51e480bb83f6a1425dffa8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#aac55e026fc51e480bb83f6a1425dffa8">getAdjListStr</a> (std::string node) const</td></tr>
<tr class="memdesc:aac55e026fc51e480bb83f6a1425dffa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the string representation of the adjacency list of a node by its name(immutable).  <br /></td></tr>
<tr class="separator:aac55e026fc51e480bb83f6a1425dffa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e17afcf5f267b11b18da77a4c012050" id="r_a9e17afcf5f267b11b18da77a4c012050"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a9e17afcf5f267b11b18da77a4c012050">adjNodes</a> (int node1, int node2)</td></tr>
<tr class="memdesc:a9e17afcf5f267b11b18da77a4c012050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if two nodes are adjacent by their indexes.  <br /></td></tr>
<tr class="separator:a9e17afcf5f267b11b18da77a4c012050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d76d44e8e8f970a47c7cf4d94cb71e" id="r_a63d76d44e8e8f970a47c7cf4d94cb71e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a63d76d44e8e8f970a47c7cf4d94cb71e">adjNodes</a> (std::string node1, std::string node2)</td></tr>
<tr class="memdesc:a63d76d44e8e8f970a47c7cf4d94cb71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if two nodes are adjacent by their names.  <br /></td></tr>
<tr class="separator:a63d76d44e8e8f970a47c7cf4d94cb71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098bbbafef69bd8dc00a60b5e8e6ee4" id="r_ac098bbbafef69bd8dc00a60b5e8e6ee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ac098bbbafef69bd8dc00a60b5e8e6ee4">connectedNodes</a> (int node1, int node2)</td></tr>
<tr class="memdesc:ac098bbbafef69bd8dc00a60b5e8e6ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if two nodes are connected by their indexes.  <br /></td></tr>
<tr class="separator:ac098bbbafef69bd8dc00a60b5e8e6ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa249f69f7906a68ad8b189ed8e3809bd" id="r_aa249f69f7906a68ad8b189ed8e3809bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#aa249f69f7906a68ad8b189ed8e3809bd">connectedNodes</a> (std::string node1, std::string node2)</td></tr>
<tr class="memdesc:aa249f69f7906a68ad8b189ed8e3809bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check if two nodes are connected by their names.  <br /></td></tr>
<tr class="separator:aa249f69f7906a68ad8b189ed8e3809bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2ea8691694752083d00fe743529799" id="r_a8b2ea8691694752083d00fe743529799"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a8b2ea8691694752083d00fe743529799">getEdgesVector</a> () const</td></tr>
<tr class="memdesc:a8b2ea8691694752083d00fe743529799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the edges of the graph as a vector of tuples.  <br /></td></tr>
<tr class="separator:a8b2ea8691694752083d00fe743529799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f45c9edc82d7a54661cf4c45b5ed54" id="r_ac7f45c9edc82d7a54661cf4c45b5ed54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ac7f45c9edc82d7a54661cf4c45b5ed54">operator=</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;g2)</td></tr>
<tr class="memdesc:ac7f45c9edc82d7a54661cf4c45b5ed54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to assign a new graph to the current graph.  <br /></td></tr>
<tr class="separator:ac7f45c9edc82d7a54661cf4c45b5ed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f70226f8c69a024b38012cfa4b75c9f" id="r_a0f70226f8c69a024b38012cfa4b75c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a0f70226f8c69a024b38012cfa4b75c9f">assign</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;g2)</td></tr>
<tr class="memdesc:a0f70226f8c69a024b38012cfa4b75c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign a new graph to the current graph.  <br /></td></tr>
<tr class="separator:a0f70226f8c69a024b38012cfa4b75c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80a3020522fb713bb9ca5d6b7846ab6" id="r_ae80a3020522fb713bb9ca5d6b7846ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ae80a3020522fb713bb9ca5d6b7846ab6">copyNew</a> () const</td></tr>
<tr class="memdesc:ae80a3020522fb713bb9ca5d6b7846ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to copy the current graph into a new graph in dynamic memory.  <br /></td></tr>
<tr class="separator:ae80a3020522fb713bb9ca5d6b7846ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b2f2a08e1fde4e3070a06aae074f7d" id="r_a63b2f2a08e1fde4e3070a06aae074f7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a63b2f2a08e1fde4e3070a06aae074f7d">getMaxDegree</a> () const</td></tr>
<tr class="memdesc:a63b2f2a08e1fde4e3070a06aae074f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the maximum degree of the graph(immutable).  <br /></td></tr>
<tr class="separator:a63b2f2a08e1fde4e3070a06aae074f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a47497296c76fe0a11a780b2198a82f" id="r_a4a47497296c76fe0a11a780b2198a82f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a4a47497296c76fe0a11a780b2198a82f">getAverageDegree</a> () const</td></tr>
<tr class="memdesc:a4a47497296c76fe0a11a780b2198a82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the average degree of the graph(immutable).  <br /></td></tr>
<tr class="separator:a4a47497296c76fe0a11a780b2198a82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba858b7ef193989735be9d4d455ec16" id="r_abba858b7ef193989735be9d4d455ec16"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#abba858b7ef193989735be9d4d455ec16">getNodeToIndexMap</a> () const</td></tr>
<tr class="memdesc:abba858b7ef193989735be9d4d455ec16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the node to index map(immutable).  <br /></td></tr>
<tr class="separator:abba858b7ef193989735be9d4d455ec16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b65bf523d429fa5547929e50f26c19" id="r_a38b65bf523d429fa5547929e50f26c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a38b65bf523d429fa5547929e50f26c19">print</a> () const</td></tr>
<tr class="memdesc:a38b65bf523d429fa5547929e50f26c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to print the graph.  <br /></td></tr>
<tr class="separator:a38b65bf523d429fa5547929e50f26c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d18779cdbdec04dae51a306a65a3d9" id="r_ad5d18779cdbdec04dae51a306a65a3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#ad5d18779cdbdec04dae51a306a65a3d9">saveEdgesToFile</a> (std::string outputFolder, std::string filename) const</td></tr>
<tr class="memdesc:ad5d18779cdbdec04dae51a306a65a3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to save the graph edges to a file.  <br /></td></tr>
<tr class="separator:ad5d18779cdbdec04dae51a306a65a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a79c651475c3d603e9c6372c734061663" id="r_a79c651475c3d603e9c6372c734061663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#a79c651475c3d603e9c6372c734061663">adjMatrix</a></td></tr>
<tr class="memdesc:a79c651475c3d603e9c6372c734061663"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacency matrix, public for easy access  <br /></td></tr>
<tr class="separator:a79c651475c3d603e9c6372c734061663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9b35daf97a59f9cb664927a98b47c7" id="r_acd9b35daf97a59f9cb664927a98b47c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; int, int, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWeightedEdgeGraph.html#acd9b35daf97a59f9cb664927a98b47c7">edgesVector</a></td></tr>
<tr class="memdesc:acd9b35daf97a59f9cb664927a98b47c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of edges as tuples (node1ID, node2ID, weight)  <br /></td></tr>
<tr class="separator:acd9b35daf97a59f9cb664927a98b47c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1523d1fe59886ee43c26e15fcd58d55" name="ab1523d1fe59886ee43c26e15fcd58d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1523d1fe59886ee43c26e15fcd58d55">&#9670;&#160;</a></span>WeightedEdgeGraph() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for creating an empty weighted edge graph. </p>
<p>Initializes the graph with zero nodes and edges, and allocates memory for the adjacency matrix(with 0x0 elements). </p>

</div>
</div>
<a id="a46e8ec9dc0aebd35818be4555c111bdd" name="a46e8ec9dc0aebd35818be4555c111bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e8ec9dc0aebd35818be4555c111bdd">&#9670;&#160;</a></span>WeightedEdgeGraph() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a weighted edge graph with a specified number of nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNodes</td><td>The number of nodes in the graph.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the graph with the specified number of nodes and zero edges, and allocates memory for the adjacency matrix(with nxn elements). </p>

</div>
</div>
<a id="adda55d58f9e50f27158bbf243a46d8f2" name="adda55d58f9e50f27158bbf243a46d8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda55d58f9e50f27158bbf243a46d8f2">&#9670;&#160;</a></span>WeightedEdgeGraph() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a weighted edge graph with specified node names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeNames</td><td>A vector of strings representing the names of the nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the graph with the specified node names and zero edges, and allocates memory for the adjacency matrix(with nxn elements). </p>

</div>
</div>
<a id="a6e1267e5cc0534ecc6565f600595270c" name="a6e1267e5cc0534ecc6565f600595270c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1267e5cc0534ecc6565f600595270c">&#9670;&#160;</a></span>WeightedEdgeGraph() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a weighted edge graph with specified node names and values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeNames</td><td>A vector of strings representing the names of the nodes. </td></tr>
    <tr><td class="paramname">nodeVal</td><td>A vector of doubles representing the values of the nodes.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the graph with the specified node names and values, and zero edges, and allocates memory for the adjacency matrix(with nxn elements). </p>

</div>
</div>
<a id="ab574c12b8823863bb8570c0ad3e62579" name="ab574c12b8823863bb8570c0ad3e62579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab574c12b8823863bb8570c0ad3e62579">&#9670;&#160;</a></span>WeightedEdgeGraph() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>_adjMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating a weighted edge graph from an adjacency matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_adjMatrix</td><td>The adjacency matrix representing the graph.</td></tr>
  </table>
  </dd>
</dl>
<p>Initializes the graph with the specified adjacency matrix. Edges are added based on the non-zero values in the matrix. </p><dl class="section warning"><dt>Warning</dt><dd>The adjacency matrix must be square (same number of rows and columns). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the adjacency matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43bb43eb23adc27906e698767a3d4f92" name="a43bb43eb23adc27906e698767a3d4f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bb43eb23adc27906e698767a3d4f92">&#9670;&#160;</a></span>~WeightedEdgeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WeightedEdgeGraph::~WeightedEdgeGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for cleaning up the allocated memory. </p>
<p>Deallocates the memory used for the node values. Memory handling for adjMatrix is done in the <a class="el" href="classMatrix.html" title="Generic 2D matrix implementation using flat row-major storage.">Matrix</a> class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaa03f9df08719471ee4698bc88cb34ea" name="aaa03f9df08719471ee4698bc88cb34ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa03f9df08719471ee4698bc88cb34ea">&#9670;&#160;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The index of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The index of the second node. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight of the edge. </td></tr>
    <tr><td class="paramname">directed</td><td>Whether the edge is directed (default is true).</td></tr>
  </table>
  </dd>
</dl>
<p>Adds an edge between the specified nodes with the given weight. If the edge already exists, it updates the weight. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function doesn't throw exceptions for invalid node indexes. It just prints an error message in cerror and continues </dd></dl>

</div>
</div>
<a id="a8bbb2587b4771c016bdd36f6be62cee2" name="a8bbb2587b4771c016bdd36f6be62cee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbb2587b4771c016bdd36f6be62cee2">&#9670;&#160;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add an edge to the graph using node names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1name</td><td>The name of the first node. </td></tr>
    <tr><td class="paramname">node2name</td><td>The name of the second node. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight of the edge. </td></tr>
    <tr><td class="paramname">directed</td><td>Whether the edge is directed (default is true).</td></tr>
  </table>
  </dd>
</dl>
<p>Adds an edge between the specified nodes with the given weight. If the edge already exists, it updates the weight. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function doesn't throw exceptions for invalid node names. It just prints an error message in cerror and continues </dd></dl>

</div>
</div>
<a id="a3ec9cac4c7991f04ffe7044d01348754" name="a3ec9cac4c7991f04ffe7044d01348754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec9cac4c7991f04ffe7044d01348754">&#9670;&#160;</a></span>addNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNode </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a node to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value of the node (default is 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Adds a node with the specified value to the graph. The node is added at the end of the adjacency matrix and the adjacency list. The name of the node will be set to the index (so same name and index) </p>

</div>
</div>
<a id="a165ea3dae2483f4e59d31c87ded4927b" name="a165ea3dae2483f4e59d31c87ded4927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165ea3dae2483f4e59d31c87ded4927b">&#9670;&#160;</a></span>addNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add a node to the graph with a specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the node (default is 0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Adds a node with the specified name and value to the graph. The node is added at the end of the adjacency matrix and the adjacency list. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name already exists in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad902cfe44e2526ed5587cbee3d9a5333" name="ad902cfe44e2526ed5587cbee3d9a5333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad902cfe44e2526ed5587cbee3d9a5333">&#9670;&#160;</a></span>addNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add multiple nodes to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of doubles representing the values of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Adds multiple nodes with the specified values to the graph. The nodes are added at the end of the adjacency matrix and the adjacency list.</p>
<p>The names of the nodes will be set to the index (so same name and index) </p>

</div>
</div>
<a id="a241b845b5980b8c3c1d54889915e6bb4" name="a241b845b5980b8c3c1d54889915e6bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241b845b5980b8c3c1d54889915e6bb4">&#9670;&#160;</a></span>addNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>std::vector&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add multiple nodes to the graph with specified names and values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings representing the names of the nodes. </td></tr>
    <tr><td class="paramname">values</td><td>A vector of doubles representing the values of the nodes (default is an empty vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Adds multiple nodes with the specified names and values to the graph. The nodes are added at the end of the adjacency matrix and the adjacency list. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the some of the node names already exist in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb151a19f4b2713dfaa37adeed3afd4e" name="abb151a19f4b2713dfaa37adeed3afd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb151a19f4b2713dfaa37adeed3afd4e">&#9670;&#160;</a></span>addNodesAndCopyNew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNodesAndCopyNew </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add multiple nodes to the graph and copy the graph into a new graph in dynamic memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>A vector of doubles representing the values of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new graph.</dd></dl>
<p>add n nodes, where n is the size of the vector passed as input, and assign to each node its corrispondent value</p>
<p>Copy the graph into a new graph in dynamic memory</p>
<p>Internally uses the addNodes function to add the nodes to the new graph. </p>

</div>
</div>
<a id="a842b8a68ecd898fd51fba251f0637182" name="a842b8a68ecd898fd51fba251f0637182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842b8a68ecd898fd51fba251f0637182">&#9670;&#160;</a></span>addNodesAndCopyNew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::addNodesAndCopyNew </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>std::vector&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to add multiple nodes to the graph and copy the graph into a new graph in dynamic memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings representing the names of the nodes. </td></tr>
    <tr><td class="paramname">values</td><td>A vector of doubles representing the values of the nodes (default is an empty vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new graph.</dd></dl>
<p>add n nodes(with n names), where n is the size of the vector passed as input, and assign to each node its corrispondent value</p>
<p>Copy the graph into a new graph in dynamic memory.</p>
<p>Internally uses the addNodes function to add the nodes to the new graph </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the some of the node names already exist in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e17afcf5f267b11b18da77a4c012050" name="a9e17afcf5f267b11b18da77a4c012050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e17afcf5f267b11b18da77a4c012050">&#9670;&#160;</a></span>adjNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WeightedEdgeGraph::adjNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if two nodes are adjacent by their indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The index of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The index of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are adjacent, false otherwise. </dd></dl>

</div>
</div>
<a id="a63d76d44e8e8f970a47c7cf4d94cb71e" name="a63d76d44e8e8f970a47c7cf4d94cb71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d76d44e8e8f970a47c7cf4d94cb71e">&#9670;&#160;</a></span>adjNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WeightedEdgeGraph::adjNodes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if two nodes are adjacent by their names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The name of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The name of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are adjacent, false otherwise. </dd></dl>

</div>
</div>
<a id="a0f70226f8c69a024b38012cfa4b75c9f" name="a0f70226f8c69a024b38012cfa4b75c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f70226f8c69a024b38012cfa4b75c9f">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WeightedEdgeGraph::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign a new graph to the current graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g2</td><td>The graph to assign.</td></tr>
  </table>
  </dd>
</dl>
<p>This function assigns a new graph to the current graph. It copies the adjacency matrix, node values, and adjacency list from the new graph. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not implemented yet. </dd></dl>

</div>
</div>
<a id="ac098bbbafef69bd8dc00a60b5e8e6ee4" name="ac098bbbafef69bd8dc00a60b5e8e6ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098bbbafef69bd8dc00a60b5e8e6ee4">&#9670;&#160;</a></span>connectedNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WeightedEdgeGraph::connectedNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if two nodes are connected by their indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The index of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The index of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are connected, false otherwise.</dd></dl>
<p>Two nodes are connected if there is a path between them.</p>
<p>This function uses the adjacency list to check if the nodes are connected. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not implemented yet. </dd>
<dd>
The order of the nodes is important. The function will return true only if there exists a path from node1 to node2. </dd></dl>

</div>
</div>
<a id="aa249f69f7906a68ad8b189ed8e3809bd" name="aa249f69f7906a68ad8b189ed8e3809bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa249f69f7906a68ad8b189ed8e3809bd">&#9670;&#160;</a></span>connectedNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WeightedEdgeGraph::connectedNodes </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to check if two nodes are connected by their names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The name of the first node. It is used as the starting point of the search. </td></tr>
    <tr><td class="paramname">node2</td><td>The name of the second node. It is used as the target of the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the nodes are connected, false otherwise.</dd></dl>
<p>Two nodes are connected if there is a path between them.</p>
<p>This function uses the adjacency list to check if the nodes are connected. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not completely implemented yet. Only returns true if the nodes are also adjacent. </dd>
<dd>
The order of the nodes is important. The function will return true only if there exists a path from node1 to node2. </dd></dl>

</div>
</div>
<a id="a9d3bf2e7b630fc443a430ab6a5ecf1f1" name="a9d3bf2e7b630fc443a430ab6a5ecf1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3bf2e7b630fc443a430ab6a5ecf1f1">&#9670;&#160;</a></span>containsNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WeightedEdgeGraph::containsNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to know if a node is in the graph(immutable) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the node is in the graph, false otherwise. </dd></dl>

</div>
</div>
<a id="ae80a3020522fb713bb9ca5d6b7846ab6" name="ae80a3020522fb713bb9ca5d6b7846ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80a3020522fb713bb9ca5d6b7846ab6">&#9670;&#160;</a></span>copyNew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::copyNew </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to copy the current graph into a new graph in dynamic memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new graph.</dd></dl>
<p>This function copies the current graph into a new graph in dynamic memory. It uses the copy constructor to create the new graph. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not implemented yet. </dd></dl>

</div>
</div>
<a id="ad80f2ecd2beaecc5655af4158b1a2f27" name="ad80f2ecd2beaecc5655af4158b1a2f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80f2ecd2beaecc5655af4158b1a2f27">&#9670;&#160;</a></span>degreeOfNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::degreeOfNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the degree of a certain node in the graph(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the degree of the node.</dd></dl>
<p>The degree of a node is the number of edges that are connected to the node.</p>
<p>The degree of a node is the sum of its in degree and out degree. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab81c1ac5331d89636ef6ee0be9629023" name="ab81c1ac5331d89636ef6ee0be9629023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81c1ac5331d89636ef6ee0be9629023">&#9670;&#160;</a></span>getAdjList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; int &gt; WeightedEdgeGraph::getAdjList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the adjacency list of a node by its index(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the adjacent nodes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad408a4eb90ced6e0253c2f783c8f1221" name="ad408a4eb90ced6e0253c2f783c8f1221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad408a4eb90ced6e0253c2f783c8f1221">&#9670;&#160;</a></span>getAdjList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; int &gt; WeightedEdgeGraph::getAdjList </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the adjacency list of a node by its name(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the adjacent nodes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name is not found in the graph.</td></tr>
  </table>
  </dd>
</dl>
<p>Internally calls the getAdjList(int node) function. </p><dl class="section see"><dt>See also</dt><dd>getAdjList(int node) </dd>
<dd>
getIndexFromName(std::string name) </dd>
<dd>
<a class="el" href="classWeightedEdgeGraph.html#abba858b7ef193989735be9d4d455ec16" title="Function to get the node to index map(immutable).">getNodeToIndexMap()</a> </dd></dl>

</div>
</div>
<a id="a374d247510ef156ff79075a0fadf76e0" name="a374d247510ef156ff79075a0fadf76e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374d247510ef156ff79075a0fadf76e0">&#9670;&#160;</a></span>getAdjListStr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string WeightedEdgeGraph::getAdjListStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the string representation of the adjacency list of a node by its index(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the adjacency list of the specified node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the getAdjList(int node) function to get the adjacency list of the specified node and then converts it to a string. </p><dl class="section see"><dt>See also</dt><dd>getAdjList(int node) </dd></dl>

</div>
</div>
<a id="aac55e026fc51e480bb83f6a1425dffa8" name="aac55e026fc51e480bb83f6a1425dffa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac55e026fc51e480bb83f6a1425dffa8">&#9670;&#160;</a></span>getAdjListStr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string WeightedEdgeGraph::getAdjListStr </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the string representation of the adjacency list of a node by its name(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the adjacency list of the specified node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name is not found in the graph.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the getAdjList(std::string node) function to get the adjacency list of the specified node and then converts it to a string. </p><dl class="section see"><dt>See also</dt><dd>getAdjList(std::string node) </dd></dl>

</div>
</div>
<a id="a4a47497296c76fe0a11a780b2198a82f" name="a4a47497296c76fe0a11a780b2198a82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a47497296c76fe0a11a780b2198a82f">&#9670;&#160;</a></span>getAverageDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double WeightedEdgeGraph::getAverageDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the average degree of the graph(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>The average degree of the graph.</dd></dl>
<p>The average degree of the graph is the sum of the degrees of all nodes divided by the number of nodes. </p>

</div>
</div>
<a id="a8b2ea8691694752083d00fe743529799" name="a8b2ea8691694752083d00fe743529799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2ea8691694752083d00fe743529799">&#9670;&#160;</a></span>getEdgesVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; int, int, double &gt; &gt; WeightedEdgeGraph::getEdgesVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the edges of the graph as a vector of tuples. </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of tuples representing the edges of the graph.</dd></dl>
<p>Each tuple contains the index of the first node, the index of the second node, and the weight of the edge. </p>

</div>
</div>
<a id="a45d7a47ac0dd1ec17466250a6713a89d" name="a45d7a47ac0dd1ec17466250a6713a89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d7a47ac0dd1ec17466250a6713a89d">&#9670;&#160;</a></span>getEdgeWeight() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double WeightedEdgeGraph::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the weight of an edge between two nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The index of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The index of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the edge between the specified nodes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if one of the nodes is out of range (index). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a750eb82403adfe2ddae8b6ad75b50bec" name="a750eb82403adfe2ddae8b6ad75b50bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750eb82403adfe2ddae8b6ad75b50bec">&#9670;&#160;</a></span>getEdgeWeight() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double WeightedEdgeGraph::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the weight of an edge between two nodes using their names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The name of the first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The name of the second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weight of the edge between the specified nodes. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if one of the nodes is out of range (meaning that no node has that name). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a441ff5c47a1cd44684b7ebc6fb3f2494" name="a441ff5c47a1cd44684b7ebc6fb3f2494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441ff5c47a1cd44684b7ebc6fb3f2494">&#9670;&#160;</a></span>getIndexFromName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::getIndexFromName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the index of a node by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the node. Or -1 if the node is not found. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function doesn't throw exceptions for invalid node names. It just returns -1 if the node is not found.</dd></dl>
<p>This function is used to get the index of a node by its name. It uses the nodeToIndex map to find the index. </p>

</div>
</div>
<a id="a63b2f2a08e1fde4e3070a06aae074f7d" name="a63b2f2a08e1fde4e3070a06aae074f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b2f2a08e1fde4e3070a06aae074f7d">&#9670;&#160;</a></span>getMaxDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::getMaxDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the maximum degree of the graph(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum degree of the graph.</dd></dl>
<p>The maximum degree of the graph is the maximum degree of all nodes in the graph. </p>

</div>
</div>
<a id="a14e716dbe1a72138daca3478f39f0bb5" name="a14e716dbe1a72138daca3478f39f0bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e716dbe1a72138daca3478f39f0bb5">&#9670;&#160;</a></span>getNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; WeightedEdgeGraph::getNeighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the neighbors of a node by its index(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the neighbors of the specified node.</dd></dl>
<p>The neighbors of a node are the nodes that are directly connected to the specified node (both entering and exiting neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses both the predecessors and successors functions to get the neighbors of the specified node. </p><dl class="section see"><dt>See also</dt><dd>getPredecessors(int node) </dd>
<dd>
getSuccessors(int node) </dd></dl>

</div>
</div>
<a id="acc42c47f150546dcc0ab07a25216deca" name="acc42c47f150546dcc0ab07a25216deca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc42c47f150546dcc0ab07a25216deca">&#9670;&#160;</a></span>getNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; WeightedEdgeGraph::getNeighbors </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the neighbors of a node by its name(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of names representing the neighbors of the specified node.</dd></dl>
<p>The neighbors of a node are the nodes that are directly connected to the specified node (both entering and exiting neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the getIndexFromName(std::string name) function to get the index of the node and then calls the getNeighbors(int node) function. </p><dl class="section see"><dt>See also</dt><dd>getIndexFromName(std::string name) </dd>
<dd>
getNeighbors(int node) </dd></dl>

</div>
</div>
<a id="a0c9aadcfc05bf0fe0ab75e1318146f42" name="a0c9aadcfc05bf0fe0ab75e1318146f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9aadcfc05bf0fe0ab75e1318146f42">&#9670;&#160;</a></span>getNodeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string WeightedEdgeGraph::getNodeName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the node name by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the specified node.</dd></dl>
<p>This function retrieves the name of a node based on its index in the graph. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check if the node exists in the graph, it only checks the index. </dd></dl>

</div>
</div>
<a id="aed769ff58f478aaccf711bd0252d61d3" name="aed769ff58f478aaccf711bd0252d61d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed769ff58f478aaccf711bd0252d61d3">&#9670;&#160;</a></span>getNodeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; WeightedEdgeGraph::getNodeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the names of the nodes in the graph(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings representing the names of the nodes. </dd></dl>

</div>
</div>
<a id="abba858b7ef193989735be9d4d455ec16" name="abba858b7ef193989735be9d4d455ec16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba858b7ef193989735be9d4d455ec16">&#9670;&#160;</a></span>getNodeToIndexMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, int &gt; WeightedEdgeGraph::getNodeToIndexMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to get the node to index map(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>A map of node names to indexes.</dd></dl>
<p>This function just returns the private member nodeToIndex. </p>

</div>
</div>
<a id="aa8fb3424f09147387c69ff7f39ffc23e" name="aa8fb3424f09147387c69ff7f39ffc23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fb3424f09147387c69ff7f39ffc23e">&#9670;&#160;</a></span>getNodeValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double WeightedEdgeGraph::getNodeValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the value of a node by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a779d6c8587d6fc1d452110271fda8139" name="a779d6c8587d6fc1d452110271fda8139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779d6c8587d6fc1d452110271fda8139">&#9670;&#160;</a></span>getNodeValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double WeightedEdgeGraph::getNodeValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the value of a node by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the specified node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name is not found in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11802cc18552ac393876d86eab64a0be" name="a11802cc18552ac393876d86eab64a0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11802cc18552ac393876d86eab64a0be">&#9670;&#160;</a></span>getNodeValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; WeightedEdgeGraph::getNodeValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the values of multiple nodes by their indexes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A vector of integers representing the indexes of the nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of doubles representing the values of the specified nodes.</dd></dl>
<p>If the vector is empty, returns all node values. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node indexes are out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73efc6e50ff603098d8904ac0a36b84c" name="a73efc6e50ff603098d8904ac0a36b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73efc6e50ff603098d8904ac0a36b84c">&#9670;&#160;</a></span>getNodeValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; WeightedEdgeGraph::getNodeValues </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em> = <code>std::vector&lt;std::string&gt;()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the values of multiple nodes by their names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A vector of strings representing the names of the nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of doubles representing the values of the specified nodes.</dd></dl>
<p>If the vector is empty, returns all node values. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node names are not found in the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c94e60e58a2e8aefac52fe8db3391d" name="a12c94e60e58a2e8aefac52fe8db3391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c94e60e58a2e8aefac52fe8db3391d">&#9670;&#160;</a></span>getnodeValuesStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string WeightedEdgeGraph::getnodeValuesStr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the string representation of the node values(immutable) </p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the node values.</dd></dl>
<p>This function returns a string representation of the node values in the graph. </p>

</div>
</div>
<a id="a1dbd44f62fae942ab2fd71ac3f9f31b5" name="a1dbd44f62fae942ab2fd71ac3f9f31b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbd44f62fae942ab2fd71ac3f9f31b5">&#9670;&#160;</a></span>getNumEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::getNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the number of edges in the graph(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a3513ceac058873d1d9f4eb590c89c896" name="a3513ceac058873d1d9f4eb590c89c896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3513ceac058873d1d9f4eb590c89c896">&#9670;&#160;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the number of nodes in the graph(immutable). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes in the graph. </dd></dl>

</div>
</div>
<a id="a9f0455f9437b86554fb36209b736211e" name="a9f0455f9437b86554fb36209b736211e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0455f9437b86554fb36209b736211e">&#9670;&#160;</a></span>getPredecessors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; WeightedEdgeGraph::getPredecessors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the predecessors of a node by its index(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the predecessors of the specified node.</dd></dl>
<p>The predecessors of a node are the nodes that have edges directed towards the specified node (entering neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46261714b6fe50b311cd727dbb6ce043" name="a46261714b6fe50b311cd727dbb6ce043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46261714b6fe50b311cd727dbb6ce043">&#9670;&#160;</a></span>getPredecessors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; WeightedEdgeGraph::getPredecessors </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the predecessors of a node by its name(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of names representing the predecessors of the specified node.</dd></dl>
<p>The predecessors of a node are the nodes that have edges directed towards the specified node (entering neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the getIndexFromName(std::string name) function to get the index of the node and then calls the getPredecessors(int node) function. </p><dl class="section see"><dt>See also</dt><dd>getIndexFromName(std::string name) </dd>
<dd>
getPredecessors(int node) </dd></dl>

</div>
</div>
<a id="ab7fc593e03daa34d9c0fcc1a24865f5a" name="ab7fc593e03daa34d9c0fcc1a24865f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fc593e03daa34d9c0fcc1a24865f5a">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; WeightedEdgeGraph::getSuccessors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the successors of a node by its index(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the successors of the specified node.</dd></dl>
<p>The successors of a node are the nodes that have edges directed away from the specified node (exiting neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the adjacency list to get the successors of the specified node. </p><dl class="section see"><dt>See also</dt><dd>getAdjList(int node) </dd></dl>

</div>
</div>
<a id="a2c1127dc0c0e930555827172d1015710" name="a2c1127dc0c0e930555827172d1015710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1127dc0c0e930555827172d1015710">&#9670;&#160;</a></span>getSuccessors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; WeightedEdgeGraph::getSuccessors </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the successors of a node by its name(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>The name of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of names representing the successors of the specified node.</dd></dl>
<p>The successors of a node are the nodes that have edges directed away from the specified node (exiting neighbors). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes)</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the getIndexFromName(std::string name) function to get the index of the node and then calls the getSuccessors(int node) function. </p><dl class="section see"><dt>See also</dt><dd>getIndexFromName(std::string name) </dd>
<dd>
getSuccessors(int node) </dd></dl>

</div>
</div>
<a id="a2766c352071d25a6da4b8a2cce0f8db0" name="a2766c352071d25a6da4b8a2cce0f8db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2766c352071d25a6da4b8a2cce0f8db0">&#9670;&#160;</a></span>inDegreeOfNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::inDegreeOfNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the in degree of a certain node in the graph(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the in degree of the node.</dd></dl>
<p>The in degree of a node is the number of edges that are directed towards the node. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3877b03277780ad7634365a771193c5" name="ae3877b03277780ad7634365a771193c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3877b03277780ad7634365a771193c5">&#9670;&#160;</a></span>makeMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt; WeightedEdgeGraph::makeMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to create a new adjacency matrix from the current graph. </p>
<dl class="section return"><dt>Returns</dt><dd>A new adjacency matrix representing the graph.</dd></dl>
<p>This function creates a new adjacency matrix from the current graph. It is suggested not to use this function as it may cause memory leaks. </p><dl class="section warning"><dt>Warning</dt><dd>This function is not implemented completely and will probably be removed in the future. </dd></dl>

</div>
</div>
<a id="ac7f45c9edc82d7a54661cf4c45b5ed54" name="ac7f45c9edc82d7a54661cf4c45b5ed54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f45c9edc82d7a54661cf4c45b5ed54">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp; WeightedEdgeGraph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator to assign a new graph to the current graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g2</td><td>The graph to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current graph.</dd></dl>
<p>This operator assigns a new graph to the current graph. It copies the adjacency matrix, node values, and adjacency list from the new graph. </p>

</div>
</div>
<a id="a1cf9979070b8837a84ef80a4e99265b2" name="a1cf9979070b8837a84ef80a4e99265b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf9979070b8837a84ef80a4e99265b2">&#9670;&#160;</a></span>outDegreeOfNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int WeightedEdgeGraph::outDegreeOfNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the out degree of a certain node in the graph(immutable). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an integer representing the out degree of the node.</dd></dl>
<p>The out degree of a node is the number of edges that are directed away from the node. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range.(-1 or greater than the number of nodes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38b65bf523d429fa5547929e50f26c19" name="a38b65bf523d429fa5547929e50f26c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b65bf523d429fa5547929e50f26c19">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WeightedEdgeGraph::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to print the graph. </p>
<p>This function prints the graph to the standard output. It uses the operator&lt;&lt; to print the graph. </p>

</div>
</div>
<a id="ad5d18779cdbdec04dae51a306a65a3d9" name="ad5d18779cdbdec04dae51a306a65a3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d18779cdbdec04dae51a306a65a3d9">&#9670;&#160;</a></span>saveEdgesToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WeightedEdgeGraph::saveEdgesToFile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>outputFolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to save the graph edges to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputFolder</td><td>The folder where the file will be saved. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the file.</td></tr>
  </table>
  </dd>
</dl>
<p>This function saves the graph edges to a file. The file will be saved in the specified folder with the specified name.</p>
<p>The file will be saved in the following format: </p><div class="fragment"><div class="line">node1 node2 weight</div>
</div><!-- fragment --><p>The function will overwrite the file if it already exists. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the file is not opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac176fd34f2b9d4e38cf35d416dcfcaae" name="ac176fd34f2b9d4e38cf35d416dcfcaae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac176fd34f2b9d4e38cf35d416dcfcaae">&#9670;&#160;</a></span>setNodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::setNodeName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodenameTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodenameSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the names of the nodes in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodenameTarget</td><td>The name of the node to change. </td></tr>
    <tr><td class="paramname">nodenameSet</td><td>The new name for the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Sets the name of the specified node to the given new name. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name is not found in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c86e57f044655608a3e27551147269b" name="a2c86e57f044655608a3e27551147269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c86e57f044655608a3e27551147269b">&#9670;&#160;</a></span>setNodesNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::setNodesNames </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodenameSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodenameTargets</em> = <code>std::vector&lt;std::string&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the names of multiple nodes in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodenameSets</td><td>A vector of strings representing the new names for the nodes. </td></tr>
    <tr><td class="paramname">nodenameTargets</td><td>A vector of strings representing the names of the nodes to change (default is an empty vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Sets the names of the specified nodes to the given new names.</p>
<p>If provided with one parameter, controls the vector size and sets the node names if they are of the same size.</p>
<p>If provided with two parameters, changes the nodes in nodenameTargets with the values in nodenameSets. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node names are not found in the graph or if the sizes of the vectors are not equal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fa05d3d6e955d4559dd3cb5e75e7dcb" name="a1fa05d3d6e955d4559dd3cb5e75e7dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa05d3d6e955d4559dd3cb5e75e7dcb">&#9670;&#160;</a></span>setNodeValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::setNodeValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the value of a node by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The index of the node. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Sets the value of the specified node to the given value. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node index is out of range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab723f9a865013c8e72b19b2395bca6b8" name="ab723f9a865013c8e72b19b2395bca6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab723f9a865013c8e72b19b2395bca6b8">&#9670;&#160;</a></span>setNodeValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * WeightedEdgeGraph::setNodeValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the value of a node by its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The name of the node. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated graph.</dd></dl>
<p>Sets the value of the specified node to the given value. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the node name is not found in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a79c651475c3d603e9c6372c734061663" name="a79c651475c3d603e9c6372c734061663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c651475c3d603e9c6372c734061663">&#9670;&#160;</a></span>adjMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a>&lt;double&gt; WeightedEdgeGraph::adjMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjacency matrix, public for easy access </p>

</div>
</div>
<a id="acd9b35daf97a59f9cb664927a98b47c7" name="acd9b35daf97a59f9cb664927a98b47c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9b35daf97a59f9cb664927a98b47c7">&#9670;&#160;</a></span>edgesVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::tuple&lt;int, int, double&gt; &gt; WeightedEdgeGraph::edgesVector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vector of edges as tuples (node1ID, node2ID, weight) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/data_structures/<a class="el" href="WeightedEdgeGraph_8hxx_source.html">WeightedEdgeGraph.hxx</a></li>
<li>src/data_structures/<a class="el" href="WeightedEdgeGraph_8cxx.html">WeightedEdgeGraph.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
