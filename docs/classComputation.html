<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MASFENON: Computation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MASFENON
   </div>
   <div id="projectbrief">Multi-Agent Adaptive Simulation Framework for Evolution in Networks of Networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classComputation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Computation Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Core class for executing propagation, dissipation, and conservation over a network in MASFENON.  
 <a href="classComputation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Computation_8hxx_source.html">Computation.hxx</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbf52cbe89710bfcf9a49b63a13f9040" id="r_acbf52cbe89710bfcf9a49b63a13f9040"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#acbf52cbe89710bfcf9a49b63a13f9040">Computation</a> ()</td></tr>
<tr class="memdesc:acbf52cbe89710bfcf9a49b63a13f9040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class.  <br /></td></tr>
<tr class="separator:acbf52cbe89710bfcf9a49b63a13f9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad14e9593597150e351ee5d3a9a87ebe" id="r_aad14e9593597150e351ee5d3a9a87ebe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aad14e9593597150e351ee5d3a9a87ebe">~Computation</a> ()</td></tr>
<tr class="memdesc:aad14e9593597150e351ee5d3a9a87ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class.  <br /></td></tr>
<tr class="separator:aad14e9593597150e351ee5d3a9a87ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bdea41ecfe001b607dc62ba751dc46" id="r_a71bdea41ecfe001b607dc62ba751dc46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a71bdea41ecfe001b607dc62ba751dc46">Computation</a> (std::string _thisCellType, const std::vector&lt; double &gt; &amp;_input)</td></tr>
<tr class="memdesc:a71bdea41ecfe001b607dc62ba751dc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object from cell type and input.  <br /></td></tr>
<tr class="separator:a71bdea41ecfe001b607dc62ba751dc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9c18737ea7d76ae8e854199fd17dc1" id="r_a3a9c18737ea7d76ae8e854199fd17dc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a3a9c18737ea7d76ae8e854199fd17dc1">Computation</a> (std::string _thisCellType, const std::vector&lt; double &gt; &amp;_input, const <a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt; &amp;_W, const std::vector&lt; std::string &gt; &amp;graphNames)</td></tr>
<tr class="memdesc:a3a9c18737ea7d76ae8e854199fd17dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor function without knowledge of the other cell types, this part can be seen as the classical algorithm without additional computation for message passing between cells, only intra-cell propagation  <br /></td></tr>
<tr class="separator:a3a9c18737ea7d76ae8e854199fd17dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1026b01eca6840ee25cf48b31c0dc5b6" id="r_a1026b01eca6840ee25cf48b31c0dc5b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a1026b01eca6840ee25cf48b31c0dc5b6">Computation</a> (std::string _thisCellType, const std::vector&lt; double &gt; &amp;_input, <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *_graph, const std::vector&lt; std::string &gt; &amp;graphNames)</td></tr>
<tr class="memdesc:a1026b01eca6840ee25cf48b31c0dc5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor function <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> without knowledge of the other cell types, this part can be seen as the classical algorithm without additional computation for message passing between cells, only intra-cell propagation  <br /></td></tr>
<tr class="separator:a1026b01eca6840ee25cf48b31c0dc5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758c80f8bd10cc85ad99144f5195132b" id="r_a758c80f8bd10cc85ad99144f5195132b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a758c80f8bd10cc85ad99144f5195132b">augmentGraph</a> (const std::vector&lt; std::string &gt; &amp;_types, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;newEdgesList=std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;(), const std::vector&lt; double &gt; &amp;newEdgesValue=std::vector&lt; double &gt;(), bool includeSelfVirtual=false)</td></tr>
<tr class="memdesc:a758c80f8bd10cc85ad99144f5195132b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augment the graph with types and a new set of edges from virtual nodes in the augmented graph to the graph(virtual inputs and virtual outputs)  <br /></td></tr>
<tr class="separator:a758c80f8bd10cc85ad99144f5195132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ca3d28a5b2d9b533db57601334542" id="r_a111ca3d28a5b2d9b533db57601334542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a111ca3d28a5b2d9b533db57601334542">augmentGraphNoComputeInverse</a> (const std::vector&lt; std::string &gt; &amp;_types, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;newEdgesList=std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;(), const std::vector&lt; double &gt; &amp;newEdgesValue=std::vector&lt; double &gt;(), bool includeSelfVirtual=false)</td></tr>
<tr class="memdesc:a111ca3d28a5b2d9b533db57601334542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augment the graph with types and a new set of edges from virtual nodes in the augmented graph to the graph(virtual inputs and virtual outputs)  <br /></td></tr>
<tr class="separator:a111ca3d28a5b2d9b533db57601334542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e1eb23f946db111c9dedbd055999e2" id="r_a26e1eb23f946db111c9dedbd055999e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a26e1eb23f946db111c9dedbd055999e2">addEdges</a> (const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;newEdgesList, const std::vector&lt; double &gt; &amp;newEdgesValues, bool bothDirections=false, bool inverseComputation=true)</td></tr>
<tr class="memdesc:a26e1eb23f946db111c9dedbd055999e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges to the graph.  <br /></td></tr>
<tr class="separator:a26e1eb23f946db111c9dedbd055999e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d671676509462b95cd5233c85d8bd" id="r_a953d671676509462b95cd5233c85d8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a953d671676509462b95cd5233c85d8bd">addEdges</a> (const std::vector&lt; std::tuple&lt; std::string, std::string, double &gt; &gt; &amp;newEdgesList, bool bothDirections=false, bool inverseComputation=true)</td></tr>
<tr class="memdesc:a953d671676509462b95cd5233c85d8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges to the graph.  <br /></td></tr>
<tr class="separator:a953d671676509462b95cd5233c85d8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6ae2269013d9faf168fe7475a26eb3" id="r_a5d6ae2269013d9faf168fe7475a26eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a5d6ae2269013d9faf168fe7475a26eb3">addEdges</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;newEdgesList, const std::vector&lt; double &gt; &amp;newEdgesValue, bool bothDirections=false, bool inverseComputation=true)</td></tr>
<tr class="memdesc:a5d6ae2269013d9faf168fe7475a26eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges to the graph.  <br /></td></tr>
<tr class="separator:a5d6ae2269013d9faf168fe7475a26eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfaf02984124c77c7b00f5e5511b57b" id="r_abbfaf02984124c77c7b00f5e5511b57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#abbfaf02984124c77c7b00f5e5511b57b">addEdges</a> (const std::vector&lt; std::tuple&lt; int, int, double &gt; &gt; &amp;newEdgesList, bool bothDirections=false, bool inverseComputation=true)</td></tr>
<tr class="memdesc:abbfaf02984124c77c7b00f5e5511b57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges to the graph.  <br /></td></tr>
<tr class="separator:abbfaf02984124c77c7b00f5e5511b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcda698a5efecc40030252b47ebd3ef" id="r_a9dcda698a5efecc40030252b47ebd3ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a9dcda698a5efecc40030252b47ebd3ef">addEdgesAndNodes</a> (const std::vector&lt; std::tuple&lt; std::string, std::string, double &gt; &gt; &amp;newEdgesList, bool bothDirections=false, bool inverseComputation=true)</td></tr>
<tr class="memdesc:a9dcda698a5efecc40030252b47ebd3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges and the nodes present in the edges list to the graph.  <br /></td></tr>
<tr class="separator:a9dcda698a5efecc40030252b47ebd3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096722d47b13a9936bf14c7e1b4ba721" id="r_a096722d47b13a9936bf14c7e1b4ba721"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a096722d47b13a9936bf14c7e1b4ba721">computePerturbation</a> ()</td></tr>
<tr class="memdesc:a096722d47b13a9936bf14c7e1b4ba721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perturbation of the graph.  <br /></td></tr>
<tr class="separator:a096722d47b13a9936bf14c7e1b4ba721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865fc29e9e48087be18c3468d3f60791" id="r_a865fc29e9e48087be18c3468d3f60791"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a865fc29e9e48087be18c3468d3f60791">computeAugmentedPerturbation</a> ()</td></tr>
<tr class="memdesc:a865fc29e9e48087be18c3468d3f60791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perturbation of the augmented graph.  <br /></td></tr>
<tr class="separator:a865fc29e9e48087be18c3468d3f60791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19b32aabfab0e0850871cfa7ea3e9e7" id="r_aa19b32aabfab0e0850871cfa7ea3e9e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aa19b32aabfab0e0850871cfa7ea3e9e7">computeAugmentedPerturbationDissipatedAfterCompute</a> (double timeStep)</td></tr>
<tr class="memdesc:aa19b32aabfab0e0850871cfa7ea3e9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perturbation of the augmented graph with dissipation. The dissipation is done after propagation.  <br /></td></tr>
<tr class="separator:aa19b32aabfab0e0850871cfa7ea3e9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421c967e68a716a5d8a29d11dc4f7544" id="r_a421c967e68a716a5d8a29d11dc4f7544"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a421c967e68a716a5d8a29d11dc4f7544">computeAugmentedPerturbationDissipatedBeforeCompute</a> (double timeStep)</td></tr>
<tr class="memdesc:a421c967e68a716a5d8a29d11dc4f7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perturbation of the augmented graph with dissipation. The dissipation is done before propagation.  <br /></td></tr>
<tr class="separator:a421c967e68a716a5d8a29d11dc4f7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e28da70052fe1ee0b88445954c2b57a" id="r_a6e28da70052fe1ee0b88445954c2b57a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a6e28da70052fe1ee0b88445954c2b57a">computeAugmentedPerturbationSaturatedAndDissipatedBeforeCompute</a> (double timeStep, const std::vector&lt; double &gt; &amp;saturationsVector=std::vector&lt; double &gt;())</td></tr>
<tr class="memdesc:a6e28da70052fe1ee0b88445954c2b57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perturbation of the augmented graph with dissipation and saturation. The dissipation is done before propagation.  <br /></td></tr>
<tr class="separator:a6e28da70052fe1ee0b88445954c2b57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782bbf13f2f26f4fbe56d504b7ae8939" id="r_a782bbf13f2f26f4fbe56d504b7ae8939"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a782bbf13f2f26f4fbe56d504b7ae8939">computeAugmentedPerturbationEnhanced2</a> (double timeStep, bool saturation=true, const std::vector&lt; double &gt; &amp;saturationsVector=std::vector&lt; double &gt;(), const std::vector&lt; double &gt; &amp;qVector=std::vector&lt; double &gt;())</td></tr>
<tr class="separator:a782bbf13f2f26f4fbe56d504b7ae8939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9397bdd6ee7e02561b33436691e6e63" id="r_ae9397bdd6ee7e02561b33436691e6e63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ae9397bdd6ee7e02561b33436691e6e63">computeAugmentedPerturbationEnhanced3</a> (double timeStep, bool saturation=true, const std::vector&lt; double &gt; &amp;saturationsVector=std::vector&lt; double &gt;(), const std::vector&lt; double &gt; &amp;qVector=std::vector&lt; double &gt;(), std::function&lt; double(double)&gt; propagationScaleFunction=[](double time) -&gt; double{return 1.0;})</td></tr>
<tr class="separator:ae9397bdd6ee7e02561b33436691e6e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab6c6ce22620ff4ba0bf2fe9758c5cc" id="r_abab6c6ce22620ff4ba0bf2fe9758c5cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#abab6c6ce22620ff4ba0bf2fe9758c5cc">computeAugmentedPerturbationEnhanced4</a> (double timeStep, bool saturation=true, const std::vector&lt; double &gt; &amp;saturationsVector=std::vector&lt; double &gt;(), const std::vector&lt; double &gt; &amp;qVector=std::vector&lt; double &gt;())</td></tr>
<tr class="separator:abab6c6ce22620ff4ba0bf2fe9758c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d8efe55d4bb61c06919b5329a4130" id="r_ad01d8efe55d4bb61c06919b5329a4130"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ad01d8efe55d4bb61c06919b5329a4130">getMapVirtualOutputsToCellInputs</a> ()</td></tr>
<tr class="separator:ad01d8efe55d4bb61c06919b5329a4130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f6d8c0c753b383aedf0565173d930a" id="r_a66f6d8c0c753b383aedf0565173d930a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a66f6d8c0c753b383aedf0565173d930a">updateInput</a> (const std::vector&lt; double &gt; &amp;newInp=std::vector&lt; double &gt;(), bool augmented=false)</td></tr>
<tr class="separator:a66f6d8c0c753b383aedf0565173d930a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d240f22905698f5771bf19a59b3fbaf" id="r_a5d240f22905698f5771bf19a59b3fbaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a5d240f22905698f5771bf19a59b3fbaf">getInput</a> () const</td></tr>
<tr class="memdesc:a5d240f22905698f5771bf19a59b3fbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting input of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:a5d240f22905698f5771bf19a59b3fbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab713de47f4535d7a651e5f5d1cdb683f" id="r_ab713de47f4535d7a651e5f5d1cdb683f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ab713de47f4535d7a651e5f5d1cdb683f">getOutput</a> () const</td></tr>
<tr class="memdesc:ab713de47f4535d7a651e5f5d1cdb683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting output of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:ab713de47f4535d7a651e5f5d1cdb683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf1fbc026b4d481587e21fe1341407e" id="r_a2bf1fbc026b4d481587e21fe1341407e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a2bf1fbc026b4d481587e21fe1341407e">getInputAugmented</a> () const</td></tr>
<tr class="memdesc:a2bf1fbc026b4d481587e21fe1341407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting input augmented of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:a2bf1fbc026b4d481587e21fe1341407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf05cd2d33e6546171a4cb6f468f2eed" id="r_adf05cd2d33e6546171a4cb6f468f2eed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#adf05cd2d33e6546171a4cb6f468f2eed">getOutputAugmented</a> () const</td></tr>
<tr class="memdesc:adf05cd2d33e6546171a4cb6f468f2eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting output augmented of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:adf05cd2d33e6546171a4cb6f468f2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e397de41a5b726867d94e2c000f6436" id="r_a7e397de41a5b726867d94e2c000f6436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a7e397de41a5b726867d94e2c000f6436">getGraph</a> () const</td></tr>
<tr class="memdesc:a7e397de41a5b726867d94e2c000f6436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the graph pointer of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:a7e397de41a5b726867d94e2c000f6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bdb23e616dc912e2ae08a45bdf2326" id="r_a94bdb23e616dc912e2ae08a45bdf2326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a94bdb23e616dc912e2ae08a45bdf2326">getAugmentedGraph</a> () const</td></tr>
<tr class="memdesc:a94bdb23e616dc912e2ae08a45bdf2326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the augmented graph pointer of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:a94bdb23e616dc912e2ae08a45bdf2326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724bf08a4816555bc9402444998705d" id="r_aa724bf08a4816555bc9402444998705d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aa724bf08a4816555bc9402444998705d">getTypes</a> () const</td></tr>
<tr class="memdesc:aa724bf08a4816555bc9402444998705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the types of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:aa724bf08a4816555bc9402444998705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7efe19cba1c6805117f1e59793e93e" id="r_adc7efe19cba1c6805117f1e59793e93e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#adc7efe19cba1c6805117f1e59793e93e">getLocalType</a> () const</td></tr>
<tr class="memdesc:adc7efe19cba1c6805117f1e59793e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the local type of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:adc7efe19cba1c6805117f1e59793e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5eb6633f9a5b7e1c707ba3e4745ea" id="r_a24a5eb6633f9a5b7e1c707ba3e4745ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a24a5eb6633f9a5b7e1c707ba3e4745ea">isInitializedArmaNotAugmented</a> () const</td></tr>
<tr class="memdesc:a24a5eb6633f9a5b7e1c707ba3e4745ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Know if the Armadillo structure is initialized for the core graph.  <br /></td></tr>
<tr class="separator:a24a5eb6633f9a5b7e1c707ba3e4745ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c9d9190f1efc8c21f823fae8870f59" id="r_ac6c9d9190f1efc8c21f823fae8870f59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ac6c9d9190f1efc8c21f823fae8870f59">isInitializedArmaAugmented</a> () const</td></tr>
<tr class="memdesc:ac6c9d9190f1efc8c21f823fae8870f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Know if the Armadillo structure is initialized for the augmented graph.  <br /></td></tr>
<tr class="separator:ac6c9d9190f1efc8c21f823fae8870f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb61d54a0071340d95b512e25731cdcf" id="r_abb61d54a0071340d95b512e25731cdcf"><td class="memItemLeft" align="right" valign="top">arma::Col&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#abb61d54a0071340d95b512e25731cdcf">getInputArma</a> () const</td></tr>
<tr class="memdesc:abb61d54a0071340d95b512e25731cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the Armadillo input vector of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:abb61d54a0071340d95b512e25731cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa454996a47b4d986f58bb66e78981fb3" id="r_aa454996a47b4d986f58bb66e78981fb3"><td class="memItemLeft" align="right" valign="top">arma::Mat&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aa454996a47b4d986f58bb66e78981fb3">getPseudoInverseArma</a> () const</td></tr>
<tr class="memdesc:aa454996a47b4d986f58bb66e78981fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the Armadillo pseudo-inverse matrix of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:aa454996a47b4d986f58bb66e78981fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b0960721258dcb8fe9d582bafd8729" id="r_a84b0960721258dcb8fe9d582bafd8729"><td class="memItemLeft" align="right" valign="top">arma::Col&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a84b0960721258dcb8fe9d582bafd8729">getInputAugmentedArma</a> () const</td></tr>
<tr class="memdesc:a84b0960721258dcb8fe9d582bafd8729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the Armadillo input augmented vector of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object.  <br /></td></tr>
<tr class="separator:a84b0960721258dcb8fe9d582bafd8729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f788e6f65d60ea0b4926292bad5f255" id="r_a3f788e6f65d60ea0b4926292bad5f255"><td class="memItemLeft" align="right" valign="top">arma::Mat&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a3f788e6f65d60ea0b4926292bad5f255">getPseudoInverseAugmentedArma</a> () const</td></tr>
<tr class="memdesc:a3f788e6f65d60ea0b4926292bad5f255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getting the Armadillo pseudo-inverse matrix of the augmented graph.  <br /></td></tr>
<tr class="separator:a3f788e6f65d60ea0b4926292bad5f255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c738be650ab92102d370fe3f9aecf5" id="r_ab6c738be650ab92102d370fe3f9aecf5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ab6c738be650ab92102d370fe3f9aecf5">getOutputNodeValue</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:ab6c738be650ab92102d370fe3f9aecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the output value of a node in the graph  <br /></td></tr>
<tr class="separator:ab6c738be650ab92102d370fe3f9aecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4997569b6ff4745faf9a01c381d088" id="r_abd4997569b6ff4745faf9a01c381d088"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#abd4997569b6ff4745faf9a01c381d088">getInputNodeValue</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:abd4997569b6ff4745faf9a01c381d088"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the input value of a node in the graph  <br /></td></tr>
<tr class="separator:abd4997569b6ff4745faf9a01c381d088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9f1597343b8dd8bac46c9125b189d" id="r_af8e9f1597343b8dd8bac46c9125b189d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#af8e9f1597343b8dd8bac46c9125b189d">getInputNodeValueArma</a> (std::string nodeName) const</td></tr>
<tr class="memdesc:af8e9f1597343b8dd8bac46c9125b189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of a node in the graph in the Armadillo structure  <br /></td></tr>
<tr class="separator:af8e9f1597343b8dd8bac46c9125b189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53079dd2d9f5983c8a754f580747a004" id="r_a53079dd2d9f5983c8a754f580747a004"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a53079dd2d9f5983c8a754f580747a004">setInputNodeValue</a> (std::string nodeName, double value)</td></tr>
<tr class="memdesc:a53079dd2d9f5983c8a754f580747a004"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the input value of a node in the graph  <br /></td></tr>
<tr class="separator:a53079dd2d9f5983c8a754f580747a004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44d42f2b4edae0405be05b2480f94ac" id="r_af44d42f2b4edae0405be05b2480f94ac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#af44d42f2b4edae0405be05b2480f94ac">getVirtualInputForType</a> (std::string type, std::string sourceNode=&quot;&quot;) const</td></tr>
<tr class="memdesc:af44d42f2b4edae0405be05b2480f94ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of a virtual input node in the graph  <br /></td></tr>
<tr class="separator:af44d42f2b4edae0405be05b2480f94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98115bc558e61ab0ee016a5043ff9a4f" id="r_a98115bc558e61ab0ee016a5043ff9a4f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a98115bc558e61ab0ee016a5043ff9a4f">getVirtualOutputForType</a> (std::string type, std::string targetNode=&quot;&quot;) const</td></tr>
<tr class="memdesc:a98115bc558e61ab0ee016a5043ff9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of a virtual output node in the graph  <br /></td></tr>
<tr class="separator:a98115bc558e61ab0ee016a5043ff9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6338c4411df3d426e8f3cf2eab14cefa" id="r_a6338c4411df3d426e8f3cf2eab14cefa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a6338c4411df3d426e8f3cf2eab14cefa">setInputVinForType</a> (std::string type, double value, std::string sourceNode=&quot;&quot;)</td></tr>
<tr class="memdesc:a6338c4411df3d426e8f3cf2eab14cefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the value of a virtual input node in the graph  <br /></td></tr>
<tr class="separator:a6338c4411df3d426e8f3cf2eab14cefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b70259bad1a57f876d3dfbf2085197c" id="r_a9b70259bad1a57f876d3dfbf2085197c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a9b70259bad1a57f876d3dfbf2085197c">setInputVoutForType</a> (std::string type, double value, std::string targetNode=&quot;&quot;)</td></tr>
<tr class="memdesc:a9b70259bad1a57f876d3dfbf2085197c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the value of a virtual output node in the graph  <br /></td></tr>
<tr class="separator:a9b70259bad1a57f876d3dfbf2085197c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021cd1cf15e88b89ef4582cb9075f7d0" id="r_a021cd1cf15e88b89ef4582cb9075f7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a021cd1cf15e88b89ef4582cb9075f7d0">setDissipationModel</a> (<a class="el" href="classDissipationModel.html">DissipationModel</a> *dissipationModel)</td></tr>
<tr class="memdesc:a021cd1cf15e88b89ef4582cb9075f7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the Dissipation model of the graph (passing the pointer to the instance of the model)  <br /></td></tr>
<tr class="separator:a021cd1cf15e88b89ef4582cb9075f7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3208e93c8c0e9a6457d784f53aaf86f1" id="r_a3208e93c8c0e9a6457d784f53aaf86f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a3208e93c8c0e9a6457d784f53aaf86f1">setConservationModel</a> (<a class="el" href="classConservationModel.html">ConservationModel</a> *conservationModel)</td></tr>
<tr class="memdesc:a3208e93c8c0e9a6457d784f53aaf86f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the Conservation model of the graph (passing the pointer to the instance of the model)  <br /></td></tr>
<tr class="separator:a3208e93c8c0e9a6457d784f53aaf86f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaf275927756668c568a7be5ef70137" id="r_a5aaf275927756668c568a7be5ef70137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a5aaf275927756668c568a7be5ef70137">setPropagationModel</a> (<a class="el" href="classPropagationModel.html">PropagationModel</a> *propagationModel)</td></tr>
<tr class="memdesc:a5aaf275927756668c568a7be5ef70137"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the Propagation model of the graph (passing the pointer to the instance of the model)  <br /></td></tr>
<tr class="separator:a5aaf275927756668c568a7be5ef70137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4294e5775d96cc3403c8a92b9c94b56" id="r_ab4294e5775d96cc3403c8a92b9c94b56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ab4294e5775d96cc3403c8a92b9c94b56">setInputAugmented</a> (const std::vector&lt; double &gt; &amp;inputAugmented)</td></tr>
<tr class="memdesc:ab4294e5775d96cc3403c8a92b9c94b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the value of all the input nodes in the graph  <br /></td></tr>
<tr class="separator:ab4294e5775d96cc3403c8a92b9c94b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106027f0b0cc2be340237eb8f611bc56" id="r_a106027f0b0cc2be340237eb8f611bc56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a106027f0b0cc2be340237eb8f611bc56">setGraph</a> (<a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *_graph)</td></tr>
<tr class="memdesc:a106027f0b0cc2be340237eb8f611bc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the graph of the computation object  <br /></td></tr>
<tr class="separator:a106027f0b0cc2be340237eb8f611bc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33727a75970bcb247dec42fb5cada02c" id="r_a33727a75970bcb247dec42fb5cada02c"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(double, double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a33727a75970bcb247dec42fb5cada02c">getSaturationFunction</a> () const</td></tr>
<tr class="memdesc:a33727a75970bcb247dec42fb5cada02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the saturation function  <br /></td></tr>
<tr class="separator:a33727a75970bcb247dec42fb5cada02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4726fbd111a3276299d55c56b8ca7735" id="r_a4726fbd111a3276299d55c56b8ca7735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a4726fbd111a3276299d55c56b8ca7735">setSaturationFunction</a> (std::function&lt; double(double, double)&gt; saturationFunction)</td></tr>
<tr class="memdesc:a4726fbd111a3276299d55c56b8ca7735"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the saturation function  <br /></td></tr>
<tr class="separator:a4726fbd111a3276299d55c56b8ca7735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab813459d7172f3192249ea6d28e21a99" id="r_ab813459d7172f3192249ea6d28e21a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#ab813459d7172f3192249ea6d28e21a99">resetVirtualOutputs</a> ()</td></tr>
<tr class="memdesc:ab813459d7172f3192249ea6d28e21a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the virtual outputs for the computation, setting them to 0  <br /></td></tr>
<tr class="separator:ab813459d7172f3192249ea6d28e21a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8db370a06370ddb1f7ced489a4e686" id="r_aef8db370a06370ddb1f7ced489a4e686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aef8db370a06370ddb1f7ced489a4e686">freeAugmentedGraphs</a> ()</td></tr>
<tr class="memdesc:aef8db370a06370ddb1f7ced489a4e686"><td class="mdescLeft">&#160;</td><td class="mdescRight">free the Augmented graph  <br /></td></tr>
<tr class="separator:aef8db370a06370ddb1f7ced489a4e686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dfcb9d377f0413559f7898f29adb36" id="r_a65dfcb9d377f0413559f7898f29adb36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a65dfcb9d377f0413559f7898f29adb36">freeFunctions</a> ()</td></tr>
<tr class="memdesc:a65dfcb9d377f0413559f7898f29adb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">free the models used in the computation, that is the dissipation, conservation and propagation models  <br /></td></tr>
<tr class="separator:a65dfcb9d377f0413559f7898f29adb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e060ed80bfa62a4c0820737fa5a6563" id="r_a0e060ed80bfa62a4c0820737fa5a6563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComputation.html">Computation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a0e060ed80bfa62a4c0820737fa5a6563">operator=</a> (const <a class="el" href="classComputation.html">Computation</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0e060ed80bfa62a4c0820737fa5a6563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class.  <br /></td></tr>
<tr class="separator:a0e060ed80bfa62a4c0820737fa5a6563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354dd27b71ccd4a27ba5a184c22b386b" id="r_a354dd27b71ccd4a27ba5a184c22b386b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComputation.html">Computation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#a354dd27b71ccd4a27ba5a184c22b386b">copy</a> () const</td></tr>
<tr class="memdesc:a354dd27b71ccd4a27ba5a184c22b386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class.  <br /></td></tr>
<tr class="separator:a354dd27b71ccd4a27ba5a184c22b386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8e31b1612a0c0ab0a18cb1a6cb1e56" id="r_aac8e31b1612a0c0ab0a18cb1a6cb1e56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComputation.html#aac8e31b1612a0c0ab0a18cb1a6cb1e56">assign</a> (const <a class="el" href="classComputation.html">Computation</a> &amp;rhs)</td></tr>
<tr class="memdesc:aac8e31b1612a0c0ab0a18cb1a6cb1e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class.  <br /></td></tr>
<tr class="separator:aac8e31b1612a0c0ab0a18cb1a6cb1e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core class for executing propagation, dissipation, and conservation over a network in MASFENON. </p>
<p>Handles data transformations, internal and augmented graph representations, and provides matrix operations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acbf52cbe89710bfcf9a49b63a13f9040" name="acbf52cbe89710bfcf9a49b63a13f9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf52cbe89710bfcf9a49b63a13f9040">&#9670;&#160;</a></span>Computation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Computation::Computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class. </p>
<p>Initializes the computation object with default values. Not typically used in practice. </p>

</div>
</div>
<a id="aad14e9593597150e351ee5d3a9a87ebe" name="aad14e9593597150e351ee5d3a9a87ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad14e9593597150e351ee5d3a9a87ebe">&#9670;&#160;</a></span>~Computation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Computation::~Computation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class. </p>
<p>Cleans up resources and memory used by the computation object. </p>

</div>
</div>
<a id="a71bdea41ecfe001b607dc62ba751dc46" name="a71bdea41ecfe001b607dc62ba751dc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bdea41ecfe001b607dc62ba751dc46">&#9670;&#160;</a></span>Computation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Computation::Computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_thisCellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object from cell type and input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thisCellType</td><td>The cell type of the current agent. </td></tr>
    <tr><td class="paramname">_input</td><td>Initial values for the computation.</td></tr>
  </table>
  </dd>
</dl>
<p>technically, this constructor is not used in the code, but it is useful for testing purposes. </p>

</div>
</div>
<a id="a3a9c18737ea7d76ae8e854199fd17dc1" name="a3a9c18737ea7d76ae8e854199fd17dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9c18737ea7d76ae8e854199fd17dc1">&#9670;&#160;</a></span>Computation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Computation::Computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_thisCellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix.html">Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>graphNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor function without knowledge of the other cell types, this part can be seen as the classical algorithm without additional computation for message passing between cells, only intra-cell propagation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thisCellType</td><td>the type of this computation, this information will be used as the unique name for the Agent </td></tr>
    <tr><td class="paramname">_input</td><td>input vector of the nodes values, initially the one passed in the input </td></tr>
    <tr><td class="paramname">_W</td><td>the adjacency matrix along the values of every edge in the graph that it represents </td></tr>
    <tr><td class="paramname">graphNames</td><td>the graph nodes names, in order defined by the adjacency matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1026b01eca6840ee25cf48b31c0dc5b6" name="a1026b01eca6840ee25cf48b31c0dc5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1026b01eca6840ee25cf48b31c0dc5b6">&#9670;&#160;</a></span>Computation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Computation::Computation </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>_thisCellType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td>
          <td class="paramname"><em>_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>graphNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor function <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> without knowledge of the other cell types, this part can be seen as the classical algorithm without additional computation for message passing between cells, only intra-cell propagation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thisCellType</td><td>the type of this computation, this information will be used as the unique name for the Agent </td></tr>
    <tr><td class="paramname">_input</td><td>input vector of the nodes values, initially the one passed in the input </td></tr>
    <tr><td class="paramname">_graph</td><td>the graph object that represents the structure of the agent associated with the computation </td></tr>
    <tr><td class="paramname">graphNames</td><td>the graph nodes names, in order defined by the adjacency matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d6ae2269013d9faf168fe7475a26eb3" name="a5d6ae2269013d9faf168fe7475a26eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6ae2269013d9faf168fe7475a26eb3">&#9670;&#160;</a></span>addEdges() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::addEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bothDirections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverseComputation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of couple of integers, representing the edge(node ids) and its weight </td></tr>
    <tr><td class="paramname">newEdgesValue</td><td>the list of edges weights to be added to the graph, in the form of a vector of doubles (default is an empty vector, so no values are added) </td></tr>
    <tr><td class="paramname">bothDirections</td><td>if true, the edges will be added in both directions (default is false) </td></tr>
    <tr><td class="paramname">inverseComputation</td><td>if true, the pseudo-inverse of the augmented graph will be computed (default is true)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will add the edges to the graph and compute the pseudo-inverse of the augmented graph if inverseComputation is true. </p><dl class="section warning"><dt>Warning</dt><dd>function is not implemented </dd></dl>

</div>
</div>
<a id="a26e1eb23f946db111c9dedbd055999e2" name="a26e1eb23f946db111c9dedbd055999e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e1eb23f946db111c9dedbd055999e2">&#9670;&#160;</a></span>addEdges() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::addEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bothDirections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverseComputation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of pairs of strings (default is an empty vector, so no edges are added) </td></tr>
    <tr><td class="paramname">newEdgesValues</td><td>the list of edges weights to be added to the graph, in the form of a vector of doubles (default is an empty vector, so no values are added) </td></tr>
    <tr><td class="paramname">bothDirections</td><td>if true, the edges will be added in both directions (default is false) </td></tr>
    <tr><td class="paramname">inverseComputation</td><td>if true, the pseudo-inverse of the augmented graph will be computed (default is true)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will add the edges to the graph and compute the pseudo-inverse of the augmented graph if inverseComputation is true. </p><dl class="section warning"><dt>Warning</dt><dd>function is deprecated, since pseudo inverse is only useful when the propagation function uses the pseudoinverse, otherwise it's wasted space </dd></dl>

</div>
</div>
<a id="abbfaf02984124c77c7b00f5e5511b57b" name="abbfaf02984124c77c7b00f5e5511b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfaf02984124c77c7b00f5e5511b57b">&#9670;&#160;</a></span>addEdges() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::addEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; int, int, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bothDirections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverseComputation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of triples of 2 integers and a double, representing the edge and its weight </td></tr>
    <tr><td class="paramname">bothDirections</td><td>if true, the edges will be added in both directions (default is false) </td></tr>
    <tr><td class="paramname">inverseComputation</td><td>if true, the pseudo-inverse of the augmented graph will be computed (default is true)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will add the edges to the graph and compute the pseudo-inverse of the augmented graph if inverseComputation is true. </p><dl class="section warning"><dt>Warning</dt><dd>function is not implemented </dd></dl>

</div>
</div>
<a id="a953d671676509462b95cd5233c85d8bd" name="a953d671676509462b95cd5233c85d8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953d671676509462b95cd5233c85d8bd">&#9670;&#160;</a></span>addEdges() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::addEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; std::string, std::string, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bothDirections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverseComputation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of triples of 2 string and a double, representing the edge and its weight </td></tr>
    <tr><td class="paramname">bothDirections</td><td>if true, the edges will be added in both directions (default is false) </td></tr>
    <tr><td class="paramname">inverseComputation</td><td>if true, the pseudo-inverse of the augmented graph will be computed (default is true)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will add the edges to the graph and compute the pseudo-inverse of the augmented graph if inverseComputation is true. </p>

</div>
</div>
<a id="a9dcda698a5efecc40030252b47ebd3ef" name="a9dcda698a5efecc40030252b47ebd3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcda698a5efecc40030252b47ebd3ef">&#9670;&#160;</a></span>addEdgesAndNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::addEdgesAndNodes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; std::string, std::string, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bothDirections</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverseComputation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges and the nodes present in the edges list to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of triples of 2 string and a double, representing the edge and its weight </td></tr>
    <tr><td class="paramname">bothDirections</td><td>if true, the edges will be added in both directions (default is false) </td></tr>
    <tr><td class="paramname">inverseComputation</td><td>if true, the pseudo-inverse of the augmented graph will be computed (default is true)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will add the edges to the graph and compute the pseudo-inverse of the augmented graph if inverseComputation is true. The function will also add the nodes present in the edges list to the graph, if the node is not already present in the graph. </p>

</div>
</div>
<a id="aac8e31b1612a0c0ab0a18cb1a6cb1e56" name="aac8e31b1612a0c0ab0a18cb1a6cb1e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8e31b1612a0c0ab0a18cb1a6cb1e56">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComputation.html">Computation</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object to assign from.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator allows for the assignment of one <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object to another. </p>

</div>
</div>
<a id="a758c80f8bd10cc85ad99144f5195132b" name="a758c80f8bd10cc85ad99144f5195132b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758c80f8bd10cc85ad99144f5195132b">&#9670;&#160;</a></span>augmentGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::augmentGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em> = <code>std::vector&lt;std::pair&lt;std::string,std::string&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesValue</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeSelfVirtual</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augment the graph with types and a new set of edges from virtual nodes in the augmented graph to the graph(virtual inputs and virtual outputs) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_types</td><td>the types other than this type, the other agents in the network </td></tr>
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of pairs of strings (default is an empty vector, so no edges are added) </td></tr>
    <tr><td class="paramname">newEdgesValue</td><td>the list of edges weights to be added to the graph, in the form of a vector of doubles (default is an empty vector, so no values are added) </td></tr>
    <tr><td class="paramname">includeSelfVirtual</td><td>if true, the graph will be augmented with a virtual node that represents the input of the current agent (default is false)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will create a new graph with the same sub-structure as the original graph, but with additional edges and nodes. The new edges will be added to the graph, and the new nodes will be added to the graph. The new nodes will be added to the graph with different names. The new edges will be added to the graph with weights. The function will also compute the pseudo-inverse of the augmented graph and store it in the pseudoInverseAugmentedArma variable. </p><dl class="section warning"><dt>Warning</dt><dd>function is deprecated, since pseudo inverse is only useful when the propagation function uses the pseudoinverse, otherwise it's wasted space </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use the function augmentGraphNoComputeInverse. </dd></dl>

</div>
</div>
<a id="a111ca3d28a5b2d9b533db57601334542" name="a111ca3d28a5b2d9b533db57601334542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111ca3d28a5b2d9b533db57601334542">&#9670;&#160;</a></span>augmentGraphNoComputeInverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::augmentGraphNoComputeInverse </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesList</em> = <code>std::vector&lt;std::pair&lt;std::string,std::string&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newEdgesValue</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeSelfVirtual</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augment the graph with types and a new set of edges from virtual nodes in the augmented graph to the graph(virtual inputs and virtual outputs) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_types</td><td>the types other than this type, the other agents in the network </td></tr>
    <tr><td class="paramname">newEdgesList</td><td>the list of edges to be added to the graph, in the form of a vector of pairs of strings (default is an empty vector, so no edges are added) </td></tr>
    <tr><td class="paramname">newEdgesValue</td><td>the list of edges weights to be added to the graph, in the form of a vector of doubles (default is an empty vector, so no values are added) </td></tr>
    <tr><td class="paramname">includeSelfVirtual</td><td>if true, the graph will be augmented with a virtual node that represents the input of the current agent (default is false)</td></tr>
  </table>
  </dd>
</dl>
<p>The function will create a new graph with the same sub-structure as the original graph, but with additional edges and nodes. The new edges will be added to the graph, and the new nodes will be added to the graph. The new nodes will be added to the graph with different names. The new edges will be added to the graph with weights. </p><dl class="section note"><dt>Note</dt><dd>This function is the one that should be used since it's not computing any other additional variable that is used in the Propagation itself (since the propagation model handles the use of additional variables) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function adds nodes indiscriminately, see issue #43 on the repository for more information <a href="https://github.com/josura/MASFENON/issues/43">https://github.com/josura/MASFENON/issues/43</a> </dd></dl>

</div>
</div>
<a id="a865fc29e9e48087be18c3468d3f60791" name="a865fc29e9e48087be18c3468d3f60791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865fc29e9e48087be18c3468d3f60791">&#9670;&#160;</a></span>computeAugmentedPerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perturbation of the augmented graph. </p>
<p>The function will compute the perturbation of the augmented graph using the pseudo-inverse of the augmented graph and the input vector. </p><dl class="section return"><dt>Returns</dt><dd>The perturbation vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>function is deprecated, left for backward compatibility and testing purposes </dd></dl>

</div>
</div>
<a id="aa19b32aabfab0e0850871cfa7ea3e9e7" name="aa19b32aabfab0e0850871cfa7ea3e9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19b32aabfab0e0850871cfa7ea3e9e7">&#9670;&#160;</a></span>computeAugmentedPerturbationDissipatedAfterCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationDissipatedAfterCompute </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perturbation of the augmented graph with dissipation. The dissipation is done after propagation. </p>
<p>The function will compute the perturbation of the augmented graph using the pseudo-inverse of the augmented graph and the input vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeStep</td><td>the time step for the dissipation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perturbation vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>function is deprecated, left for backward compatibility and testing purposes </dd></dl>

</div>
</div>
<a id="a421c967e68a716a5d8a29d11dc4f7544" name="a421c967e68a716a5d8a29d11dc4f7544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421c967e68a716a5d8a29d11dc4f7544">&#9670;&#160;</a></span>computeAugmentedPerturbationDissipatedBeforeCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationDissipatedBeforeCompute </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perturbation of the augmented graph with dissipation. The dissipation is done before propagation. </p>
<p>The function will compute the perturbation of the augmented graph using the pseudo-inverse of the augmented graph and the input vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeStep</td><td>the time step for the dissipation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perturbation vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>function is deprecated, left for backward compatibility and testing purposes </dd></dl>

</div>
</div>
<a id="a782bbf13f2f26f4fbe56d504b7ae8939" name="a782bbf13f2f26f4fbe56d504b7ae8939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782bbf13f2f26f4fbe56d504b7ae8939">&#9670;&#160;</a></span>computeAugmentedPerturbationEnhanced2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationEnhanced2 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saturation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>saturationsVector</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qVector</em> = <code>std::vector&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9397bdd6ee7e02561b33436691e6e63" name="ae9397bdd6ee7e02561b33436691e6e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9397bdd6ee7e02561b33436691e6e63">&#9670;&#160;</a></span>computeAugmentedPerturbationEnhanced3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationEnhanced3 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saturation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>saturationsVector</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qVector</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double)&gt;&#160;</td>
          <td class="paramname"><em>propagationScaleFunction</em> = <code>[](double&#160;time)-&gt;&#160;double{return&#160;1.0;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abab6c6ce22620ff4ba0bf2fe9758c5cc" name="abab6c6ce22620ff4ba0bf2fe9758c5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab6c6ce22620ff4ba0bf2fe9758c5cc">&#9670;&#160;</a></span>computeAugmentedPerturbationEnhanced4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationEnhanced4 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saturation</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>saturationsVector</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>qVector</em> = <code>std::vector&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e28da70052fe1ee0b88445954c2b57a" name="a6e28da70052fe1ee0b88445954c2b57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e28da70052fe1ee0b88445954c2b57a">&#9670;&#160;</a></span>computeAugmentedPerturbationSaturatedAndDissipatedBeforeCompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computeAugmentedPerturbationSaturatedAndDissipatedBeforeCompute </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>saturationsVector</em> = <code>std::vector&lt;double&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perturbation of the augmented graph with dissipation and saturation. The dissipation is done before propagation. </p>
<p>The function will compute the perturbation of the augmented graph using the pseudo-inverse of the augmented graph and the input vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeStep</td><td>the time step for the dissipation </td></tr>
    <tr><td class="paramname">saturationsVector</td><td>the saturation vector for the dissipation(default to empty vector) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The perturbation vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>function is deprecated, left for backward compatibility and testing purposes </dd></dl>

</div>
</div>
<a id="a096722d47b13a9936bf14c7e1b4ba721" name="a096722d47b13a9936bf14c7e1b4ba721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096722d47b13a9936bf14c7e1b4ba721">&#9670;&#160;</a></span>computePerturbation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::computePerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perturbation of the graph. </p>
<p>The function will compute the perturbation of the graph using the pseudo-inverse of the graph and the input vector. </p><dl class="section return"><dt>Returns</dt><dd>The perturbation vector. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>function is deprecated, left for backward compatibility and testing purposes </dd></dl>

</div>
</div>
<a id="a354dd27b71ccd4a27ba5a184c22b386b" name="a354dd27b71ccd4a27ba5a184c22b386b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354dd27b71ccd4a27ba5a184c22b386b">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComputation.html">Computation</a> Computation::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class. </p>
<p>This constructor allows for the creation of a new <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object as a copy of an existing one. </p><dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This constructor does not perform a deep copy of the graph and augmented graph, ONLY THE POINTERS ARE COPIED(IMPORTANT). </dd>
<dd>
This constructor does not perform a deep copy of the dissipation, conservation and propagation models, only the pointers are copied. </dd></dl>

</div>
</div>
<a id="aef8db370a06370ddb1f7ced489a4e686" name="aef8db370a06370ddb1f7ced489a4e686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8db370a06370ddb1f7ced489a4e686">&#9670;&#160;</a></span>freeAugmentedGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::freeAugmentedGraphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free the Augmented graph </p>
<p>This function frees the memory used by the augmented graph. </p>

</div>
</div>
<a id="a65dfcb9d377f0413559f7898f29adb36" name="a65dfcb9d377f0413559f7898f29adb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dfcb9d377f0413559f7898f29adb36">&#9670;&#160;</a></span>freeFunctions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::freeFunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>free the models used in the computation, that is the dissipation, conservation and propagation models </p>
<p>This function frees the memory used by the functions used in the computation.</p>
<p>At the moment only the dissipation model is freed, the conservation and propagation models are not freed since they are the same for each computation (for now) </p><dl class="section warning"><dt>Warning</dt><dd>This function is unstable for now, it's only used for having a clean memory </dd></dl>

</div>
</div>
<a id="a94bdb23e616dc912e2ae08a45bdf2326" name="a94bdb23e616dc912e2ae08a45bdf2326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bdb23e616dc912e2ae08a45bdf2326">&#9670;&#160;</a></span>getAugmentedGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * Computation::getAugmentedGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the augmented graph pointer of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a7e397de41a5b726867d94e2c000f6436" name="a7e397de41a5b726867d94e2c000f6436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e397de41a5b726867d94e2c000f6436">&#9670;&#160;</a></span>getGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> * Computation::getGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the graph pointer of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a5d240f22905698f5771bf19a59b3fbaf" name="a5d240f22905698f5771bf19a59b3fbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d240f22905698f5771bf19a59b3fbaf">&#9670;&#160;</a></span>getInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::getInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting input of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="abb61d54a0071340d95b512e25731cdcf" name="abb61d54a0071340d95b512e25731cdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb61d54a0071340d95b512e25731cdcf">&#9670;&#160;</a></span>getInputArma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arma::Col&lt; double &gt; Computation::getInputArma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the Armadillo input vector of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a2bf1fbc026b4d481587e21fe1341407e" name="a2bf1fbc026b4d481587e21fe1341407e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf1fbc026b4d481587e21fe1341407e">&#9670;&#160;</a></span>getInputAugmented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::getInputAugmented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting input augmented of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a84b0960721258dcb8fe9d582bafd8729" name="a84b0960721258dcb8fe9d582bafd8729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b0960721258dcb8fe9d582bafd8729">&#9670;&#160;</a></span>getInputAugmentedArma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arma::Col&lt; double &gt; Computation::getInputAugmentedArma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the Armadillo input augmented vector of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="abd4997569b6ff4745faf9a01c381d088" name="abd4997569b6ff4745faf9a01c381d088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4997569b6ff4745faf9a01c381d088">&#9670;&#160;</a></span>getInputNodeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Computation::getInputNodeValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the input value of a node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>the name of the node in the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double: the value of the node in the graph </dd></dl>

</div>
</div>
<a id="af8e9f1597343b8dd8bac46c9125b189d" name="af8e9f1597343b8dd8bac46c9125b189d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e9f1597343b8dd8bac46c9125b189d">&#9670;&#160;</a></span>getInputNodeValueArma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Computation::getInputNodeValueArma </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value of a node in the graph in the Armadillo structure </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>the name of the node in the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double: the value of the node in the graph </dd></dl>

</div>
</div>
<a id="adc7efe19cba1c6805117f1e59793e93e" name="adc7efe19cba1c6805117f1e59793e93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7efe19cba1c6805117f1e59793e93e">&#9670;&#160;</a></span>getLocalType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Computation::getLocalType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the local type of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="ad01d8efe55d4bb61c06919b5329a4130" name="ad01d8efe55d4bb61c06919b5329a4130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01d8efe55d4bb61c06919b5329a4130">&#9670;&#160;</a></span>getMapVirtualOutputsToCellInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; Computation::getMapVirtualOutputsToCellInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab713de47f4535d7a651e5f5d1cdb683f" name="ab713de47f4535d7a651e5f5d1cdb683f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab713de47f4535d7a651e5f5d1cdb683f">&#9670;&#160;</a></span>getOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::getOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting output of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="adf05cd2d33e6546171a4cb6f468f2eed" name="adf05cd2d33e6546171a4cb6f468f2eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf05cd2d33e6546171a4cb6f468f2eed">&#9670;&#160;</a></span>getOutputAugmented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Computation::getOutputAugmented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting output augmented of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="ab6c738be650ab92102d370fe3f9aecf5" name="ab6c738be650ab92102d370fe3f9aecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c738be650ab92102d370fe3f9aecf5">&#9670;&#160;</a></span>getOutputNodeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Computation::getOutputNodeValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the output value of a node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>the name of the node in the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double: the value of the node in the graph </dd></dl>

</div>
</div>
<a id="aa454996a47b4d986f58bb66e78981fb3" name="aa454996a47b4d986f58bb66e78981fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa454996a47b4d986f58bb66e78981fb3">&#9670;&#160;</a></span>getPseudoInverseArma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt; double &gt; Computation::getPseudoInverseArma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the Armadillo pseudo-inverse matrix of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a3f788e6f65d60ea0b4926292bad5f255" name="a3f788e6f65d60ea0b4926292bad5f255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f788e6f65d60ea0b4926292bad5f255">&#9670;&#160;</a></span>getPseudoInverseAugmentedArma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt; double &gt; Computation::getPseudoInverseAugmentedArma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the Armadillo pseudo-inverse matrix of the augmented graph. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="a33727a75970bcb247dec42fb5cada02c" name="a33727a75970bcb247dec42fb5cada02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33727a75970bcb247dec42fb5cada02c">&#9670;&#160;</a></span>getSaturationFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; double(double, double)&gt; Computation::getSaturationFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the saturation function </p>
<p>This function returns the saturation function used in the computation.</p>
<p>The saturation function is a function that takes two double values as input and returns a double value. </p><dl class="section return"><dt>Returns</dt><dd>std::function&lt;double(double,double)&gt;: the saturation function <br  />
 </dd></dl>

</div>
</div>
<a id="aa724bf08a4816555bc9402444998705d" name="aa724bf08a4816555bc9402444998705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa724bf08a4816555bc9402444998705d">&#9670;&#160;</a></span>getTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Computation::getTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getting the types of the <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>The corresponding private member. </dd></dl>

</div>
</div>
<a id="af44d42f2b4edae0405be05b2480f94ac" name="af44d42f2b4edae0405be05b2480f94ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44d42f2b4edae0405be05b2480f94ac">&#9670;&#160;</a></span>getVirtualInputForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Computation::getVirtualInputForType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sourceNode</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the value of a virtual input node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of the node in the source graph </td></tr>
    <tr><td class="paramname">sourceNode</td><td>the name of the source node in the source graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double: the value of the node in the graph </dd></dl>

</div>
</div>
<a id="a98115bc558e61ab0ee016a5043ff9a4f" name="a98115bc558e61ab0ee016a5043ff9a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98115bc558e61ab0ee016a5043ff9a4f">&#9670;&#160;</a></span>getVirtualOutputForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Computation::getVirtualOutputForType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>targetNode</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the value of a virtual output node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of the node in the target graph </td></tr>
    <tr><td class="paramname">targetNode</td><td>the name of the target node in the target graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double: the value of the node in the graph </dd></dl>

</div>
</div>
<a id="ac6c9d9190f1efc8c21f823fae8870f59" name="ac6c9d9190f1efc8c21f823fae8870f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c9d9190f1efc8c21f823fae8870f59">&#9670;&#160;</a></span>isInitializedArmaAugmented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Computation::isInitializedArmaAugmented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Know if the Armadillo structure is initialized for the augmented graph. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>True if the Armadillo structure is initialized for the augmented graph, false otherwise. </dd></dl>

</div>
</div>
<a id="a24a5eb6633f9a5b7e1c707ba3e4745ea" name="a24a5eb6633f9a5b7e1c707ba3e4745ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a5eb6633f9a5b7e1c707ba3e4745ea">&#9670;&#160;</a></span>isInitializedArmaNotAugmented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Computation::isInitializedArmaNotAugmented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Know if the Armadillo structure is initialized for the core graph. </p>
<p>These functions provide access to the private members of the class, allowing read-only access to the data. </p><dl class="section return"><dt>Returns</dt><dd>True if the Armadillo structure is initialized for the core graph, false otherwise. </dd></dl>

</div>
</div>
<a id="a0e060ed80bfa62a4c0820737fa5a6563" name="a0e060ed80bfa62a4c0820737fa5a6563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e060ed80bfa62a4c0820737fa5a6563">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComputation.html">Computation</a> &amp; Computation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComputation.html">Computation</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator for <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The right-hand side <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object to assign from.</td></tr>
  </table>
  </dd>
</dl>
<p>This operator allows for the assignment of one <a class="el" href="classComputation.html" title="Core class for executing propagation, dissipation, and conservation over a network in MASFENON.">Computation</a> object to another. </p><dl class="section return"><dt>Returns</dt><dd>A reference to the current object. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator does not perform a deep copy of the graph and augmented graph, only the pointers are copied. </dd>
<dd>
This operator does not perform a deep copy of the dissipation, conservation and propagation models, only the pointers are copied. </dd></dl>

</div>
</div>
<a id="ab813459d7172f3192249ea6d28e21a99" name="ab813459d7172f3192249ea6d28e21a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab813459d7172f3192249ea6d28e21a99">&#9670;&#160;</a></span>resetVirtualOutputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::resetVirtualOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset the virtual outputs for the computation, setting them to 0 </p>
<p>This function resets the virtual output nodes values for the computation, setting them to 0. </p>

</div>
</div>
<a id="a3208e93c8c0e9a6457d784f53aaf86f1" name="a3208e93c8c0e9a6457d784f53aaf86f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3208e93c8c0e9a6457d784f53aaf86f1">&#9670;&#160;</a></span>setConservationModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setConservationModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConservationModel.html">ConservationModel</a> *&#160;</td>
          <td class="paramname"><em>conservationModel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the Conservation model of the graph (passing the pointer to the instance of the model) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conservationModel</td><td>the pointer to the instance of the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a021cd1cf15e88b89ef4582cb9075f7d0" name="a021cd1cf15e88b89ef4582cb9075f7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021cd1cf15e88b89ef4582cb9075f7d0">&#9670;&#160;</a></span>setDissipationModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setDissipationModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDissipationModel.html">DissipationModel</a> *&#160;</td>
          <td class="paramname"><em>dissipationModel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the Dissipation model of the graph (passing the pointer to the instance of the model) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dissipationModel</td><td>the pointer to the instance of the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a106027f0b0cc2be340237eb8f611bc56" name="a106027f0b0cc2be340237eb8f611bc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106027f0b0cc2be340237eb8f611bc56">&#9670;&#160;</a></span>setGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> *&#160;</td>
          <td class="paramname"><em>_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the graph of the computation object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_graph</td><td>the pointer to the graph</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the graph of the computation object to the graph passed as a parameter.</p>
<p>This function is only used for testing and pointer management.</p>
<p>This function is not really used in the code in key phases, but it is useful for testing purposes and pointer management. </p>

</div>
</div>
<a id="ab4294e5775d96cc3403c8a92b9c94b56" name="ab4294e5775d96cc3403c8a92b9c94b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4294e5775d96cc3403c8a92b9c94b56">&#9670;&#160;</a></span>setInputAugmented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setInputAugmented </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputAugmented</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the value of all the input nodes in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputAugmented</td><td>the vector of input values (augmented) to set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the value of all the input nodes in the graph to the values in the vector.</p>
<p>The size of the vector must be equal to the number of nodes in the graph.</p>
<p>The function will throw an exception if the size of the vector is not equal to the number of nodes in the graph. </p>

</div>
</div>
<a id="a53079dd2d9f5983c8a754f580747a004" name="a53079dd2d9f5983c8a754f580747a004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53079dd2d9f5983c8a754f580747a004">&#9670;&#160;</a></span>setInputNodeValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setInputNodeValue </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>nodeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the input value of a node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeName</td><td>the name of the node in the graph </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6338c4411df3d426e8f3cf2eab14cefa" name="a6338c4411df3d426e8f3cf2eab14cefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6338c4411df3d426e8f3cf2eab14cefa">&#9670;&#160;</a></span>setInputVinForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setInputVinForType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sourceNode</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the value of a virtual input node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of the node in the source graph </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">sourceNode</td><td>the name of the source node in the source graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b70259bad1a57f876d3dfbf2085197c" name="a9b70259bad1a57f876d3dfbf2085197c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b70259bad1a57f876d3dfbf2085197c">&#9670;&#160;</a></span>setInputVoutForType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setInputVoutForType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>targetNode</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the value of a virtual output node in the graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of the node in the target graph </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">targetNode</td><td>the name of the target node in the target graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aaf275927756668c568a7be5ef70137" name="a5aaf275927756668c568a7be5ef70137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaf275927756668c568a7be5ef70137">&#9670;&#160;</a></span>setPropagationModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setPropagationModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPropagationModel.html">PropagationModel</a> *&#160;</td>
          <td class="paramname"><em>propagationModel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the Propagation model of the graph (passing the pointer to the instance of the model) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propagationModel</td><td>the pointer to the instance of the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4726fbd111a3276299d55c56b8ca7735" name="a4726fbd111a3276299d55c56b8ca7735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4726fbd111a3276299d55c56b8ca7735">&#9670;&#160;</a></span>setSaturationFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::setSaturationFunction </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(double, double)&gt;&#160;</td>
          <td class="paramname"><em>saturationFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the saturation function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saturationFunction</td><td>std::function&lt;double(double;double)&gt; the saturation function to set</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the saturation function used in the computation.</p>
<p>The saturation function is a function that takes two double values as input and returns a double value. </p>

</div>
</div>
<a id="a66f6d8c0c753b383aedf0565173d930a" name="a66f6d8c0c753b383aedf0565173d930a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f6d8c0c753b383aedf0565173d930a">&#9670;&#160;</a></span>updateInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Computation::updateInput </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>newInp</em> = <code>std::vector&lt;double&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>augmented</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/computation/<a class="el" href="Computation_8hxx_source.html">Computation.hxx</a></li>
<li>src/computation/<a class="el" href="Computation_8cxx.html">Computation.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
