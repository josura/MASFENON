<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MASFENON: weighted_graph_metrics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MASFENON
   </div>
   <div id="projectbrief">Multi-Agent Adaptive Simulation Framework for Evolution in Networks of Networks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">weighted_graph_metrics Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains utility functions for calculating metrics on weighted graphs.  
<a href="namespaceweighted__graph__metrics.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adc62972d56e6dfca8d9d83b6e80a2bf0" id="r_adc62972d56e6dfca8d9d83b6e80a2bf0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> { <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0aefeb369cccbd560588a756610865664c">In</a>
, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0a7c147cda9e49590f6abe83d118b7353b">Out</a>
, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">Full</a>
 }</td></tr>
<tr class="separator:adc62972d56e6dfca8d9d83b6e80a2bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96e4885e6b887c610d059a1bdc1ebed0" id="r_a96e4885e6b887c610d059a1bdc1ebed0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a96e4885e6b887c610d059a1bdc1ebed0">averageEdgeWeight</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a96e4885e6b887c610d059a1bdc1ebed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the average weight of edges in a weighted graph.  <br /></td></tr>
<tr class="separator:a96e4885e6b887c610d059a1bdc1ebed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c712fc7c4b43b513fa7c3d4e803bde" id="r_a47c712fc7c4b43b513fa7c3d4e803bde"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a47c712fc7c4b43b513fa7c3d4e803bde">maxEdgeWeight</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a47c712fc7c4b43b513fa7c3d4e803bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum edge weight in a weighted graph.  <br /></td></tr>
<tr class="separator:a47c712fc7c4b43b513fa7c3d4e803bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12afe34560c3abcb8765042721482ab" id="r_ac12afe34560c3abcb8765042721482ab"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ac12afe34560c3abcb8765042721482ab">minEdgeWeight</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac12afe34560c3abcb8765042721482ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum edge weight in a weighted graph.  <br /></td></tr>
<tr class="separator:ac12afe34560c3abcb8765042721482ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ccec857bdbc4b02866f74818085c3" id="r_a199ccec857bdbc4b02866f74818085c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a199ccec857bdbc4b02866f74818085c3">averageEdgeDegree</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a199ccec857bdbc4b02866f74818085c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average edge degree in a weighted graph.  <br /></td></tr>
<tr class="separator:a199ccec857bdbc4b02866f74818085c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe275fc4ad149f1869c09682b253983" id="r_abfe275fc4ad149f1869c09682b253983"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#abfe275fc4ad149f1869c09682b253983">maxEdgeDegree</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:abfe275fc4ad149f1869c09682b253983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum edge degree in a weighted graph.  <br /></td></tr>
<tr class="separator:abfe275fc4ad149f1869c09682b253983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51143329e38f9727461cc5fde52feeaa" id="r_a51143329e38f9727461cc5fde52feeaa"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a51143329e38f9727461cc5fde52feeaa">minEdgeDegree</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a51143329e38f9727461cc5fde52feeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum edge degree in a weighted graph.  <br /></td></tr>
<tr class="separator:a51143329e38f9727461cc5fde52feeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2ead9501228fa8f73c0580c313053" id="r_a23d2ead9501228fa8f73c0580c313053"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a23d2ead9501228fa8f73c0580c313053">averageEdgeDegreeWeighted</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a23d2ead9501228fa8f73c0580c313053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average edge degree (weighted) in a weighted graph.  <br /></td></tr>
<tr class="separator:a23d2ead9501228fa8f73c0580c313053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2498b653e38ac90ae03b5b2431906ee4" id="r_a2498b653e38ac90ae03b5b2431906ee4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a2498b653e38ac90ae03b5b2431906ee4">maxEdgeDegreeWeighted</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a2498b653e38ac90ae03b5b2431906ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum edge degree (weighted) in a weighted graph.  <br /></td></tr>
<tr class="separator:a2498b653e38ac90ae03b5b2431906ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937700172ec4eabe348ab648efe6645" id="r_ab937700172ec4eabe348ab648efe6645"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ab937700172ec4eabe348ab648efe6645">minEdgeDegreeWeighted</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:ab937700172ec4eabe348ab648efe6645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum edge degree (weighted) in a weighted graph.  <br /></td></tr>
<tr class="separator:ab937700172ec4eabe348ab648efe6645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a28883c9b95be0aabda4c3416e4f5a3" id="r_a2a28883c9b95be0aabda4c3416e4f5a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a2a28883c9b95be0aabda4c3416e4f5a3">averageStrengthCentrality</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a2a28883c9b95be0aabda4c3416e4f5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average strength centrality in the graph.  <br /></td></tr>
<tr class="separator:a2a28883c9b95be0aabda4c3416e4f5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231415d33d2279dc80c50050ff3549bd" id="r_a231415d33d2279dc80c50050ff3549bd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a231415d33d2279dc80c50050ff3549bd">maxStrengthCentrality</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a231415d33d2279dc80c50050ff3549bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum strength centrality in the graph.  <br /></td></tr>
<tr class="separator:a231415d33d2279dc80c50050ff3549bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aaedb1c61ef4dff8e9f1987692db49" id="r_a44aaedb1c61ef4dff8e9f1987692db49"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a44aaedb1c61ef4dff8e9f1987692db49">minStrengthCentrality</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a> mode=<a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a>)</td></tr>
<tr class="memdesc:a44aaedb1c61ef4dff8e9f1987692db49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum strength centrality in the graph.  <br /></td></tr>
<tr class="separator:a44aaedb1c61ef4dff8e9f1987692db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7635c03f5832977b527061802a107cea" id="r_a7635c03f5832977b527061802a107cea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a7635c03f5832977b527061802a107cea">weightedLocalClustering</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, int v)</td></tr>
<tr class="memdesc:a7635c03f5832977b527061802a107cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the local clustering coefficient for a node in a weighted edge graph.  <br /></td></tr>
<tr class="separator:a7635c03f5832977b527061802a107cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157d69078092126c6a3d6951d5142ec2" id="r_a157d69078092126c6a3d6951d5142ec2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a157d69078092126c6a3d6951d5142ec2">weightedGlobalClustering</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a157d69078092126c6a3d6951d5142ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the global clustering coefficient for a weighted edge graph.  <br /></td></tr>
<tr class="separator:a157d69078092126c6a3d6951d5142ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66cbd1b3b4ce938a2996328ad4bc41" id="r_a2f66cbd1b3b4ce938a2996328ad4bc41"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a2f66cbd1b3b4ce938a2996328ad4bc41">weightedPathWeight</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, const std::vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a2f66cbd1b3b4ce938a2996328ad4bc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weigth of a path in a weighted edge graph.  <br /></td></tr>
<tr class="separator:a2f66cbd1b3b4ce938a2996328ad4bc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8549350ecd60d73a291f4f5ee09f32b" id="r_ad8549350ecd60d73a291f4f5ee09f32b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ad8549350ecd60d73a291f4f5ee09f32b">hasNegativeWeights</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ad8549350ecd60d73a291f4f5ee09f32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control if the graph contains negative weights.  <br /></td></tr>
<tr class="separator:ad8549350ecd60d73a291f4f5ee09f32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486039a812ae40f1fa75ed4334829f7a" id="r_a486039a812ae40f1fa75ed4334829f7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a486039a812ae40f1fa75ed4334829f7a">hasCycleUtil</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, int v, std::vector&lt; bool &gt; &amp;visited, std::vector&lt; bool &gt; &amp;recStack)</td></tr>
<tr class="memdesc:a486039a812ae40f1fa75ed4334829f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if the graph contains a cycle.  <br /></td></tr>
<tr class="separator:a486039a812ae40f1fa75ed4334829f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76129222e905c1e6a03022164b7dcba3" id="r_a76129222e905c1e6a03022164b7dcba3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a76129222e905c1e6a03022164b7dcba3">hasCycle</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a76129222e905c1e6a03022164b7dcba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control if the graph contains a cycle.  <br /></td></tr>
<tr class="separator:a76129222e905c1e6a03022164b7dcba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a19dbb93067185610c89de534a2d8" id="r_ace1a19dbb93067185610c89de534a2d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ace1a19dbb93067185610c89de534a2d8">allUnweightedShortestPathFromSourceBFS</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, int source)</td></tr>
<tr class="memdesc:ace1a19dbb93067185610c89de534a2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unweighted shortest path with BFS from a source node to all other nodes in a weighted edge graph.  <br /></td></tr>
<tr class="separator:ace1a19dbb93067185610c89de534a2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad4e75fc89dca0a8163aa1e0895dcd0" id="r_a5ad4e75fc89dca0a8163aa1e0895dcd0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a5ad4e75fc89dca0a8163aa1e0895dcd0">allWeightedShortestPathFromSourceDijkstra</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, int source)</td></tr>
<tr class="memdesc:a5ad4e75fc89dca0a8163aa1e0895dcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weighted shortest path with Dijkstra's algorithm from a source node to all other nodes in a weighted edge graph.  <br /></td></tr>
<tr class="separator:a5ad4e75fc89dca0a8163aa1e0895dcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b676cd2109b6b47a6b8d4c5cec926e" id="r_ae8b676cd2109b6b47a6b8d4c5cec926e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ae8b676cd2109b6b47a6b8d4c5cec926e">allWeightedShortestPathFromSourceBellmanFord</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph, int source)</td></tr>
<tr class="memdesc:ae8b676cd2109b6b47a6b8d4c5cec926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weighted shortest path with Bellman-Ford algorithm from a source node to all other nodes in a weighted edge graph.  <br /></td></tr>
<tr class="separator:ae8b676cd2109b6b47a6b8d4c5cec926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae175f00c642386ea5dfc2ff8796f90d5" id="r_ae175f00c642386ea5dfc2ff8796f90d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ae175f00c642386ea5dfc2ff8796f90d5">allWeightedShortestPathFloydWarshall</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ae175f00c642386ea5dfc2ff8796f90d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weighted shortest path with Floyd-Warshall algorithm all-to-all nodes in a weighted edge graph.  <br /></td></tr>
<tr class="separator:ae175f00c642386ea5dfc2ff8796f90d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d725c0fcb1cd90ffce196183f7b51f3" id="r_a6d725c0fcb1cd90ffce196183f7b51f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#a6d725c0fcb1cd90ffce196183f7b51f3">allUnweightedShortestPathFloydWarshall</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a6d725c0fcb1cd90ffce196183f7b51f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the unweighted shortest path with Floyd-Warshall algorithm all-to-all nodes in a weighted edge graph.  <br /></td></tr>
<tr class="separator:a6d725c0fcb1cd90ffce196183f7b51f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9be1abec71ea46a561df0fc78e4cd88" id="r_ac9be1abec71ea46a561df0fc78e4cd88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#ac9be1abec71ea46a561df0fc78e4cd88">graphDiameter</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac9be1abec71ea46a561df0fc78e4cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the diameter of the graph.  <br /></td></tr>
<tr class="separator:ac9be1abec71ea46a561df0fc78e4cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b96fa215c637e76c0582fcb049fafb" id="r_af4b96fa215c637e76c0582fcb049fafb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#af4b96fa215c637e76c0582fcb049fafb">averageDistance</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:af4b96fa215c637e76c0582fcb049fafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average distance between all pairs of nodes in the graph(unweighted).  <br /></td></tr>
<tr class="separator:af4b96fa215c637e76c0582fcb049fafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc760cd8f63c82a9d1c4b5bbc8e84e66" id="r_afc760cd8f63c82a9d1c4b5bbc8e84e66"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceweighted__graph__metrics.html#afc760cd8f63c82a9d1c4b5bbc8e84e66">averageWeightedDistance</a> (const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:afc760cd8f63c82a9d1c4b5bbc8e84e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the average distance between all pairs of nodes in the graph(weighted).  <br /></td></tr>
<tr class="separator:afc760cd8f63c82a9d1c4b5bbc8e84e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains utility functions for calculating metrics on weighted graphs. </p>
<p>The functions are used to calculate metrics such as the average weight of edges in a graph. </p><dl class="section note"><dt>Note</dt><dd>The functions are designed to work with the <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> class. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>When some of the functions in this namespace are used in the code, there needs to be some checks before using some functions, such as negative weights or cycles in the graph with Dijkstra's algorithm. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adc62972d56e6dfca8d9d83b6e80a2bf0" name="adc62972d56e6dfca8d9d83b6e80a2bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc62972d56e6dfca8d9d83b6e80a2bf0">&#9670;&#160;</a></span>DegreeMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">weighted_graph_metrics::DegreeMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adc62972d56e6dfca8d9d83b6e80a2bf0aefeb369cccbd560588a756610865664c" name="adc62972d56e6dfca8d9d83b6e80a2bf0aefeb369cccbd560588a756610865664c"></a>In&#160;</td><td class="fielddoc"><p>Define the mode for considering only the entering edges in the functions </p>
</td></tr>
<tr><td class="fieldname"><a id="adc62972d56e6dfca8d9d83b6e80a2bf0a7c147cda9e49590f6abe83d118b7353b" name="adc62972d56e6dfca8d9d83b6e80a2bf0a7c147cda9e49590f6abe83d118b7353b"></a>Out&#160;</td><td class="fielddoc"><p>Define the mode for considering only the exiting edges in the functions <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75" name="adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75"></a>Full&#160;</td><td class="fielddoc"><p>Define the mode for considering all the edges </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d725c0fcb1cd90ffce196183f7b51f3" name="a6d725c0fcb1cd90ffce196183f7b51f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d725c0fcb1cd90ffce196183f7b51f3">&#9670;&#160;</a></span>allUnweightedShortestPathFloydWarshall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt; weighted_graph_metrics::allUnweightedShortestPathFloydWarshall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unweighted shortest path with Floyd-Warshall algorithm all-to-all nodes in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector pairs containing the target node and the corresponding paths from the source node to a target node. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The paths are represented as vectors of node indices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the graph is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the Floyd-Warshall algorithm to compute the shortest path lengths </p>

</div>
</div>
<a id="ace1a19dbb93067185610c89de534a2d8" name="ace1a19dbb93067185610c89de534a2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1a19dbb93067185610c89de534a2d8">&#9670;&#160;</a></span>allUnweightedShortestPathFromSourceBFS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt; weighted_graph_metrics::allUnweightedShortestPathFromSourceBFS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the unweighted shortest path with BFS from a source node to all other nodes in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">source</td><td>The source node from which to compute the shortest paths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector pairs containing the target and the corresponding paths from the source node to all other nodes. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The paths are represented as vectors of node indices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the source node index is out of range. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses a breadth-first search (BFS) algorithm to compute the shortest path lengths in an unweighted graph. </p><dl class="section note"><dt>Note</dt><dd>The graph is treated as unweighted for the purpose of this function, meaning that all edges are considered to have equal weight (1). </dd></dl>

</div>
</div>
<a id="ae175f00c642386ea5dfc2ff8796f90d5" name="ae175f00c642386ea5dfc2ff8796f90d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae175f00c642386ea5dfc2ff8796f90d5">&#9670;&#160;</a></span>allWeightedShortestPathFloydWarshall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; double, std::vector&lt; int &gt; &gt; &gt; weighted_graph_metrics::allWeightedShortestPathFloydWarshall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weighted shortest path with Floyd-Warshall algorithm all-to-all nodes in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector pairs containing the shortest path weight and the corresponding paths from the source node to a target node. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The paths are represented as vectors of node indices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the graph is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the Floyd-Warshall algorithm to compute the shortest path lengths in a weighted graph. </p>

</div>
</div>
<a id="ae8b676cd2109b6b47a6b8d4c5cec926e" name="ae8b676cd2109b6b47a6b8d4c5cec926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b676cd2109b6b47a6b8d4c5cec926e">&#9670;&#160;</a></span>allWeightedShortestPathFromSourceBellmanFord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt; weighted_graph_metrics::allWeightedShortestPathFromSourceBellmanFord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weighted shortest path with Bellman-Ford algorithm from a source node to all other nodes in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">source</td><td>The source node from which to compute the shortest paths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector pairs containing the target and the corresponding paths from the source node to all other nodes. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The paths are represented as vectors of node indices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the source node index is out of range. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is empty. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the graph contains a negative weight cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses the Bellman-Ford algorithm to compute the shortest path lengths in a weighted graph. </p><dl class="section note"><dt>Note</dt><dd>The graph is treated as weighted, meaning that edges can have different weights. </dd></dl>

</div>
</div>
<a id="a5ad4e75fc89dca0a8163aa1e0895dcd0" name="a5ad4e75fc89dca0a8163aa1e0895dcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad4e75fc89dca0a8163aa1e0895dcd0">&#9670;&#160;</a></span>allWeightedShortestPathFromSourceDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, std::vector&lt; int &gt; &gt; &gt; weighted_graph_metrics::allWeightedShortestPathFromSourceDijkstra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weighted shortest path with Dijkstra's algorithm from a source node to all other nodes in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">source</td><td>The source node from which to compute the shortest paths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector pairs containing the target node and the corresponding paths from the source node to all other nodes. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The paths are represented as vectors of node indices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the source node index is out of range. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This function uses Dijkstra's algorithm to compute the shortest path lengths in a weighted graph. </p><dl class="section note"><dt>Note</dt><dd>The graph is treated as weighted, meaning that edges can have different weights. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the graph does not contain negative weight cycles. And that the weights are non-negative. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>add control for negative weights </dd></dl>

</div>
</div>
<a id="af4b96fa215c637e76c0582fcb049fafb" name="af4b96fa215c637e76c0582fcb049fafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b96fa215c637e76c0582fcb049fafb">&#9670;&#160;</a></span>averageDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the average distance between all pairs of nodes in the graph(unweighted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average distance between all pairs of nodes in the graph (unweighted).</dd></dl>
<p>The average distance is computed as the average of the shortest path lengths between all pairs of nodes in the graph. </p><dl class="section note"><dt>Note</dt><dd>The function uses the Floyd-Warshall algorithm to compute the shortest paths. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the graph is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199ccec857bdbc4b02866f74818085c3" name="a199ccec857bdbc4b02866f74818085c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199ccec857bdbc4b02866f74818085c3">&#9670;&#160;</a></span>averageEdgeDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageEdgeDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average edge degree in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average edge degree in the graph.</dd></dl>
<p>This function calculates the average degree of edges in the graph, which is defined as the average number of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the number of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the graph has no edges. </dd></dl>

</div>
</div>
<a id="a23d2ead9501228fa8f73c0580c313053" name="a23d2ead9501228fa8f73c0580c313053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d2ead9501228fa8f73c0580c313053">&#9670;&#160;</a></span>averageEdgeDegreeWeighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageEdgeDegreeWeighted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average edge degree (weighted) in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average edge degree (weighted) in the graph.</dd></dl>
<p>This function calculates the average degree of edges in the graph, which is defined as the average sum of weights of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the sum of weights of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the graph has no edges. </dd></dl>

</div>
</div>
<a id="a96e4885e6b887c610d059a1bdc1ebed0" name="a96e4885e6b887c610d059a1bdc1ebed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e4885e6b887c610d059a1bdc1ebed0">&#9670;&#160;</a></span>averageEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the average weight of edges in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average weight of the edges in the graph.</dd></dl>
<p>This function iterates through all edges in the graph and computes the average weight. </p>

</div>
</div>
<a id="a2a28883c9b95be0aabda4c3416e4f5a3" name="a2a28883c9b95be0aabda4c3416e4f5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a28883c9b95be0aabda4c3416e4f5a3">&#9670;&#160;</a></span>averageStrengthCentrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageStrengthCentrality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the average strength centrality in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the strength calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average strength centrality measure in the graph</dd></dl>
<p>This function computes the average strength centrality, where the strength is computed as: strength(v) = sum of weights of edges incident to v <br  />
 </p>

</div>
</div>
<a id="afc760cd8f63c82a9d1c4b5bbc8e84e66" name="afc760cd8f63c82a9d1c4b5bbc8e84e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc760cd8f63c82a9d1c4b5bbc8e84e66">&#9670;&#160;</a></span>averageWeightedDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::averageWeightedDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the average distance between all pairs of nodes in the graph(weighted). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average distance between all pairs of nodes in the graph (weighted).</dd></dl>
<p>The average distance is computed as the average of the shortest path lengths between all pairs of nodes in the graph. </p><dl class="section note"><dt>Note</dt><dd>The function uses the Floyd-Warshall algorithm to compute the shortest paths. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the graph is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9be1abec71ea46a561df0fc78e4cd88" name="ac9be1abec71ea46a561df0fc78e4cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9be1abec71ea46a561df0fc78e4cd88">&#9670;&#160;</a></span>graphDiameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int weighted_graph_metrics::graphDiameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the diameter of the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the graph, which is the maximum distance between any two nodes in the graph (unweighted).</dd></dl>
<p>The diameter is computed as the maximum shortest path length between any two nodes in the graph. </p><dl class="section note"><dt>Note</dt><dd>The function uses the Floyd-Warshall algorithm to compute the shortest paths. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes that the graph is connected. If the graph is not connected, the diameter may not be well-defined. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceweighted__graph__metrics.html#a6d725c0fcb1cd90ffce196183f7b51f3" title="Computes the unweighted shortest path with Floyd-Warshall algorithm all-to-all nodes in a weighted ed...">allUnweightedShortestPathFloydWarshall</a> for more details on the algorithm used. </dd></dl>

</div>
</div>
<a id="a76129222e905c1e6a03022164b7dcba3" name="a76129222e905c1e6a03022164b7dcba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76129222e905c1e6a03022164b7dcba3">&#9670;&#160;</a></span>hasCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool weighted_graph_metrics::hasCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control if the graph contains a cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the graph contains a cycle, false otherwise.</dd></dl>
<p>This function uses a depth-first search (DFS) algorithm to detect cycles (strongly connected components) in the graph. </p><dl class="section note"><dt>Note</dt><dd>The function assumes that the graph is directed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486039a812ae40f1fa75ed4334829f7a" name="a486039a812ae40f1fa75ed4334829f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486039a812ae40f1fa75ed4334829f7a">&#9670;&#160;</a></span>hasCycleUtil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool weighted_graph_metrics::hasCycleUtil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>recStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to check if the graph contains a cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">v</td><td>The current node being visited. </td></tr>
    <tr><td class="paramname">visited</td><td>A vector to track visited nodes. </td></tr>
    <tr><td class="paramname">recStack</td><td>A vector to track nodes in the current recursion stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a cycle is detected, false otherwise.</dd></dl>
<p>This function uses depth-first search (DFS) to detect cycles in the graph. </p><dl class="section note"><dt>Note</dt><dd>The function assumes that the graph is directed. </dd></dl>

</div>
</div>
<a id="ad8549350ecd60d73a291f4f5ee09f32b" name="ad8549350ecd60d73a291f4f5ee09f32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8549350ecd60d73a291f4f5ee09f32b">&#9670;&#160;</a></span>hasNegativeWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool weighted_graph_metrics::hasNegativeWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control if the graph contains negative weights. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the graph contains negative weights, false otherwise.</dd></dl>
<p>This function iterates through all edges in the graph and checks if any edge has a negative weight. </p><dl class="section note"><dt>Note</dt><dd>The function assumes that the graph is directed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the graph is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check for negative weight cycles, only for the presence of negative weights. </dd></dl>

</div>
</div>
<a id="abfe275fc4ad149f1869c09682b253983" name="abfe275fc4ad149f1869c09682b253983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe275fc4ad149f1869c09682b253983">&#9670;&#160;</a></span>maxEdgeDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, int &gt; weighted_graph_metrics::maxEdgeDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum edge degree in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum edge degree in the graph.</dd></dl>
<p>This function calculates the maximum degree of edges in the graph, which is defined as the maximum number of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the number of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pair &lt;name,value&gt;. 0 if the graph has no edges. </dd></dl>

</div>
</div>
<a id="a2498b653e38ac90ae03b5b2431906ee4" name="a2498b653e38ac90ae03b5b2431906ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2498b653e38ac90ae03b5b2431906ee4">&#9670;&#160;</a></span>maxEdgeDegreeWeighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::maxEdgeDegreeWeighted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum edge degree (weighted) in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full).</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the maximum degree of edges in the graph, which is defined as the maximum sum of weights of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the sum of weights of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pair &lt;name,value&gt; node that has the maximum edge degree. 0 if the graph has no edges. </dd></dl>

</div>
</div>
<a id="a47c712fc7c4b43b513fa7c3d4e803bde" name="a47c712fc7c4b43b513fa7c3d4e803bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c712fc7c4b43b513fa7c3d4e803bde">&#9670;&#160;</a></span>maxEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::maxEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum edge weight in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum edge weight in the graph.</dd></dl>
<p>This function iterates through all edges in the graph and finds the maximum weight. </p>

</div>
</div>
<a id="a231415d33d2279dc80c50050ff3549bd" name="a231415d33d2279dc80c50050ff3549bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231415d33d2279dc80c50050ff3549bd">&#9670;&#160;</a></span>maxStrengthCentrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::maxStrengthCentrality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the maximum strength centrality in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the strength calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum strength centrality measure in the graph and a node that has that maximum centrality</dd></dl>
<p>This function computes the maximum strength centrality, where the strength is computed as: strength(v) = sum of weights of edges incident to v <br  />
 </p>

</div>
</div>
<a id="a51143329e38f9727461cc5fde52feeaa" name="a51143329e38f9727461cc5fde52feeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51143329e38f9727461cc5fde52feeaa">&#9670;&#160;</a></span>minEdgeDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, int &gt; weighted_graph_metrics::minEdgeDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum edge degree in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum edge degree in the graph.</dd></dl>
<p>This function calculates the minimum degree of edges in the graph, which is defined as the minimum number of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the number of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pair &lt;name,value&gt;. 0 if the graph has no edges. </dd></dl>

</div>
</div>
<a id="ab937700172ec4eabe348ab648efe6645" name="ab937700172ec4eabe348ab648efe6645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab937700172ec4eabe348ab648efe6645">&#9670;&#160;</a></span>minEdgeDegreeWeighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::minEdgeDegreeWeighted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum edge degree (weighted) in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of degree calculation (In, Out, Full).</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates the minimum degree of edges in the graph, which is defined as the minimum sum of weights of edges connected to any node. </p><dl class="section note"><dt>Note</dt><dd>The degree of a node is the sum of weights of edges connected to it. Depending on the mode, it can be the in-degree, out-degree, or full degree. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pair &lt;name,value&gt; node that has the minimum edge degree. 0 if the graph has no edges. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is similar to minEdgeDegree, but it considers the weights of the edges. </dd></dl>

</div>
</div>
<a id="ac12afe34560c3abcb8765042721482ab" name="ac12afe34560c3abcb8765042721482ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12afe34560c3abcb8765042721482ab">&#9670;&#160;</a></span>minEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::minEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum edge weight in a weighted graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum edge weight in the graph.</dd></dl>
<p>This function iterates through all edges in the graph and finds the minimum weight. </p>

</div>
</div>
<a id="a44aaedb1c61ef4dff8e9f1987692db49" name="a44aaedb1c61ef4dff8e9f1987692db49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aaedb1c61ef4dff8e9f1987692db49">&#9670;&#160;</a></span>minStrengthCentrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; weighted_graph_metrics::minStrengthCentrality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0">DegreeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespaceweighted__graph__metrics.html#adc62972d56e6dfca8d9d83b6e80a2bf0abbd47109890259c0127154db1af26c75">DegreeMode::Full</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum strength centrality in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of strength calculation (In, Out, Full). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum strength centrality measure in the graph and a node that has that minimum centrality</dd></dl>
<p>This function computes the minimum strength centrality, where the strength is computed as: strength(v) = sum of weights of edges incident to v <br  />
 </p>

</div>
</div>
<a id="a157d69078092126c6a3d6951d5142ec2" name="a157d69078092126c6a3d6951d5142ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157d69078092126c6a3d6951d5142ec2">&#9670;&#160;</a></span>weightedGlobalClustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::weightedGlobalClustering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the global clustering coefficient for a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global clustering coefficient for the graph.</dd></dl>
<p>The global clustering coefficient is computed as the average of the local clustering coefficients of all the nodes in the graph. </p>

</div>
</div>
<a id="a7635c03f5832977b527061802a107cea" name="a7635c03f5832977b527061802a107cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7635c03f5832977b527061802a107cea">&#9670;&#160;</a></span>weightedLocalClustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::weightedLocalClustering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the local clustering coefficient for a node in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">v</td><td>The node for which to compute the local clustering coefficient. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local clustering coefficient for the node v.</dd></dl>
<p>The local clustering coefficient is computed as the Barrat's local clustering coefficient </p>

</div>
</div>
<a id="a2f66cbd1b3b4ce938a2996328ad4bc41" name="a2f66cbd1b3b4ce938a2996328ad4bc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f66cbd1b3b4ce938a2996328ad4bc41">&#9670;&#160;</a></span>weightedPathWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double weighted_graph_metrics::weightedPathWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeightedEdgeGraph.html">WeightedEdgeGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weigth of a path in a weighted edge graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The weighted edge graph to analyze. </td></tr>
    <tr><td class="paramname">path</td><td>A vector of node indices representing the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total weight of the path.</dd></dl>
<p>The weight of the path is computed as the sum of the weights of the edges in the path. </p><dl class="section note"><dt>Note</dt><dd>The path is represented as a vector of node indices, where each index corresponds to a node in the graph. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if any node index in the path is out of range of the graph's nodes. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the path is not valid (e.g., edges do not exist between consecutive nodes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
